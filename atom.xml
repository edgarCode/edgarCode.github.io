<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonZhang&#39;s Blog</title>
  <subtitle>开发心得</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jasonzhang1986.github.io/"/>
  <updated>2017-04-18T10:33:20.204Z</updated>
  <id>http://jasonzhang1986.github.io/</id>
  
  <author>
    <name>Jason Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>you-get遇到的坑</title>
    <link href="http://jasonzhang1986.github.io/2017/04/18/you-get/"/>
    <id>http://jasonzhang1986.github.io/2017/04/18/you-get/</id>
    <published>2017-04-18T09:37:26.264Z</published>
    <updated>2017-04-18T10:33:20.204Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>you-get好用的下载器 <a href="https://github.com/soimort/you-get" target="_blank" rel="external">https://github.com/soimort/you-get</a></p>
</li>
<li><p>我使用choco install的，官方提供了多种安装方式总有一款适合你</p>
</li>
<li><p>使用Shadowsocks代理，在下载YouTube的时候出现SSL错误，证书认证错误，查看帮助(you-get –help)看到有sock-proxy选项</p>
<p><img src="http://7u2jwu.com1.z0.glb.clouddn.com/blog/20170418/182733080.png" alt="help"></p>
</li>
<li><p>于是使用如下命令（–debug是显示debug信息）：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">you-<span class="keyword">get</span> -s <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1080</span> --debug -i <span class="string">'https://www.youtube.com/watch?v=jNQXAC9IVRw'</span></div></pre></td></tr></table></figure>
<p>结果如下图</p>
<p><img src="http://7u2jwu.com1.z0.glb.clouddn.com/blog/20170418/180732935.png" alt="info"></p>
<p>可以看到是展示了多种分辨率，那我们就可以选择需要的分辨率下载了</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">you-<span class="keyword">get</span> -s <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1080</span> --debug --itag=<span class="number">242</span> <span class="string">'https://www.youtube.com/watch?v=jNQXAC9IVRw'</span></div></pre></td></tr></table></figure>
<p>结果下载失败：</p>
<p><img src="http://7u2jwu.com1.z0.glb.clouddn.com/blog/20170418/181213644.png" alt="失败"></p>
</li>
<li><p>曾遇到过需要安装PySocks这个库，在使用pip install的时候出现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install fails <span class="keyword">with</span> “connection error: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:<span class="number">598</span>)”</div></pre></td></tr></table></figure>
<p>通过Google通过添加trust参数来解决</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip3 install --index-url=http://pypi.python.org/simple/ --trusted-host pypi.python.org  pythonPackage</div></pre></td></tr></table></figure>
</li>
<li><p>下载失败或者SSL问题仍然出现，查看issue发现不止我一人遇到这样的问题</p>
<p><a href="https://github.com/soimort/you-get/issues/1684" target="_blank" rel="external">https://github.com/soimort/you-get/issues/1684</a></p>
<p>发现也没有好的解决方案，决定换个vpn试试，改换Greenvpn之后再次尝试</p>
<p><img src="http://7u2jwu.com1.z0.glb.clouddn.com/blog/20170418/182110934.png" alt="result"></p>
<p>终于下载成功！！！</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;you-get好用的下载器 &lt;a href=&quot;https://github.com/soimort/you-get&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/soimort/you-get&lt;/a&gt;
    
    </summary>
    
      <category term="工具" scheme="http://jasonzhang1986.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Android的消息机制分析</title>
    <link href="http://jasonzhang1986.github.io/2017/03/10/Handler/"/>
    <id>http://jasonzhang1986.github.io/2017/03/10/Handler/</id>
    <published>2017-03-10T09:37:59.736Z</published>
    <updated>2017-04-18T10:30:18.321Z</updated>
    
    <content type="html"><![CDATA[<h5 id="Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。"><a href="#Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。" class="headerlink" title="Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。"></a>Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。</h5><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>今天我们主要来聊一聊进程内部的消息机制<strong>Handler</strong>。</p>
<p>从技术实现来说消息机制并不复杂，不只是Android平台,各种平台的消息机制原理基本上都是比较相似的，其中用到的主要概念有：</p>
<ol>
<li>消息发送者</li>
<li>消息队列</li>
<li>消息循环处理</li>
</ol>
<p>简单示意图如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7u2jwu.com1.z0.glb.clouddn.com/android/handler/xiaoxi01.png" alt="image" title="">
                </div>
                <div class="image-caption">image</div>
            </figure>
<p>图中表达的意思是，消息发送者通过某种方式将消息发送到消息队列中，同时还有一个消息处理循环，不断从消息队列里取消息，并进行处理。</p>
<p>Android的消息机制主要是指Handler的运行机制，Hander的运行需要相关的MessageQueue和Looper的支撑。图中右侧的部分可以理解为Android中的Looper类，这个类的内部有对应的消息队列(MessageQueue mQueue)和loop方法(取消息的循环)</p>
<p>从我们开发者的角度来说，Handler是Android消息机制的最上层接口，这使得我们在开发过程中绝大多数情况下只需要和Handler打交道就可以，Handler的使用方法也很简单，我们常常在子线程中需要更新UI时使用，常见代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">      <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">        <span class="keyword">case</span> xxx:</div><div class="line">          ...</div><div class="line">          updateUI();</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  ....</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">threadMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread()&#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.run();</div><div class="line">        ...</div><div class="line">        handler.sendMessage(msg);</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;.start();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>在子线程中创建并使用Handler：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在子线程中使用Handler</span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">       <span class="keyword">public</span> Handler mHandler;</div><div class="line"> </div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">           Looper.prepare();</div><div class="line"> </div><div class="line">           mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">                   <span class="comment">// process incoming messages here</span></div><div class="line">               &#125;</div><div class="line">           &#125;;</div><div class="line"> </div><div class="line">           Looper.loop();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>从上面两个例子，我们可以看到通过handler的sendMessage方法来发送消息，通过Looper.loop方法来进行消息循环；至于消息处理是隐藏在Loop和MessageQueue中，我们接下来会一点点来深入分析。</p>
<p>说到Handler我们先来看下它的构造方法，开发过程中经常用到的构造方法是Handler()和Handler(Looper looper);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span></span>&#123;</div><div class="line">  	<span class="keyword">final</span> MessageQueue mQueue;</div><div class="line">    <span class="keyword">final</span> Looper mLooper;</div><div class="line">    <span class="keyword">final</span> Callback mCallback;</div><div class="line">  	<span class="keyword">final</span> <span class="keyword">boolean</span> mAsynchronous;</div><div class="line">  	</div><div class="line">  	.....</div><div class="line">  </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                    klass.getCanonicalName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">        &#125;</div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">        mLooper = looper;</div><div class="line">        mQueue = looper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">    &#125;</div><div class="line">  ......</div><div class="line">    </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>通过如上代码我们可以看到构造方法目的都是为了给mLooper、mQueue、mCallback和mAsyncronous赋值，callback和async这两个我们用的较少，我们此次重点关注mLooper和mQueue。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div></pre></td></tr></table></figure>
<p>如上是我们常用的指定了Looper的构造方法，内部实现很简单，直接就赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Use the provided &#123;<span class="doctag">@link</span> Looper&#125; instead of the default one.</div><div class="line">    *</div><div class="line">    * <span class="doctag">@param</span> looper The looper, must not be null.</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">       mLooper = looper;</div><div class="line">       mQueue = looper.mQueue;</div><div class="line">       mCallback = callback;</div><div class="line">       mAsynchronous = async;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>另一个更常用的构造方法是如下这种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Handler handler = <span class="keyword">new</span> Handler();</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">   ....</div><div class="line">     </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Default constructor associates this handler with the &#123;<span class="doctag">@link</span> Looper&#125; for the</div><div class="line">     * current thread.</div><div class="line">     *</div><div class="line">     * If this thread does not have a looper, this handler won't be able to receive messages</div><div class="line">     * so an exception is thrown.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">        .....</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">        &#125;</div><div class="line">        mQueue = mLooper.mQueue;</div><div class="line">        mCallback = callback;</div><div class="line">        mAsynchronous = async;</div><div class="line">    &#125;</div><div class="line">  ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为默认构造方法没有入参，那么mLooper通过Looper自身的myLooper方法来获取，判断mLooper是否为null，如果非空则给mQueue、callback等赋值，如果等于null则说明Handler是在线程中创建并且创建前没有调用Looper的prepare()方法；那我们猜想肯定是在Looper.prepare()方法中初始化了Looper对象。</p>
<p>这里有两个疑问</p>
<ul>
<li>在Activity(UI线程)中new Handler()的时候也没有去调用Looper.prepare()，为什么没有抛异常？</li>
<li>Looper.prepare()是如何初始化Looper对象并在通过myLooper方法向外部提供引用的？</li>
</ul>
<p>我们先来看第二个问题，还是老方法直接看源码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</div><div class="line">  	<span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div><div class="line"> 	<span class="keyword">final</span> MessageQueue mQueue;</div><div class="line">    <span class="keyword">final</span> Thread mThread;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> mRun;</div><div class="line">  </div><div class="line">  	.....</div><div class="line">  </div><div class="line">	 <span class="comment">/** Initialize the current thread as a looper.</span></div><div class="line">      * This gives you a chance to create handlers that then reference</div><div class="line">      * this looper, before actually starting the loop. Be sure to call</div><div class="line">      * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</div><div class="line">      * &#123;<span class="doctag">@link</span> #quit()&#125;.</div><div class="line">      */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">        prepare(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">        &#125;</div><div class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  	....</div><div class="line">    </div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">        mRun = <span class="keyword">true</span>;</div><div class="line">        mThread = Thread.currentThread();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">   <span class="comment">/**</span></div><div class="line">     * Return the Looper object associated with the current thread.  Returns</div><div class="line">     * null if the calling thread is not associated with a Looper.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码实现很简单，就是new一个Looper对象set给sThreadLocal，然后获取是通过sThreadLocal的get方法。这样我们明白了为什么在thread中new Handler前要调用Looper.parepare()。</p>
<p>接下来我们回头看问题1，为什么在UI线程中可以直接new Handler()来使用呢？UI线程直接初始化Handler没有抛异常说明sThreadLocal.get()返回值不是空，也就是已经set过Looper对象，那是哪里设置的呢？</p>
<p>了解应用启动流程的应该知道，应用的main方法在ActivityThread中，在main方法中完成了一些初始化工作，我们来看main方法中做了什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  </div><div class="line">  ...</div><div class="line">  </div><div class="line">  Looper.prepareMainLooper();</div><div class="line">  ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">  thread.attach(<span class="keyword">false</span>);</div><div class="line">  <span class="keyword">if</span>(sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">    sMainThreadHandler = thread.getHandler();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line">  </div><div class="line">  Looper.loop();</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里我们看到了熟悉的Looper.prepare和Looper.loop，不过这里调用的是Looper的另一个方法prepareMainLooper，跟进去看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">  prepare(<span class="keyword">false</span>);</div><div class="line">  Class var0 = Looper.class;</div><div class="line">  <span class="keyword">synchronized</span>(Looper.class) &#123;</div><div class="line">    <span class="keyword">if</span>(sMainLooper != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">  prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span>(sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到prepareMainLooper()和prepare()调用的是Looper的同一个方法prepard(boolean quitAllowed)，UI线程的Looper是不允许退出的(如果允许退出，调用了quit岂不UI就无法刷新啦)，其他线程的Looper是允许退出的。</p>
<p>所以，UI线程并非特殊，而是在更早的时候系统已经做好了Looper的初始化操作。既然已经发现了系统初始化Looper的地方，那UI线程是不是也有自己的Handler来处理消息呢？答案显示是有的。</p>
<p>prepare方法调用后，创建Handler,这里是new ActivityThread对象，ActivityThread有实例变量mH就是Handler的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">main() &#123;</div><div class="line">    ...</div><div class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">        sMainThreadHandler = thread.getHandler();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">final</span> ActivityThread.H mH = <span class="keyword">new</span> ActivityThread.H(<span class="keyword">null</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.mH;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-消息循环"><a href="#2-消息循环" class="headerlink" title="2. 消息循环"></a>2. 消息循环</h4><p>到这里<strong>Looper</strong>和<strong>Handler</strong>都准备好，还有个必须要做的就是开启消息循环<strong>Looper.loop()</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Run the message queue in this thread. Be sure to call</div><div class="line">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line">		</div><div class="line">		...</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//永久循环</span></div><div class="line">            Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123; <span class="comment">//死循环退出条件</span></div><div class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ...</div><div class="line"></div><div class="line">            msg.target.dispatchMessage(msg);<span class="comment">//这里的target是Handler</span></div><div class="line"></div><div class="line">            ...</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>说到消息的循环，就不得不提MessageQueue中next方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// Return here if the message loop has already quit and been disposed.</span></div><div class="line">        <span class="comment">// This can happen if the application tries to restart a looper after quit</span></div><div class="line">        <span class="comment">// which is not supported.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</div><div class="line">        <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">        <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">           ......</div><div class="line">             </div><div class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></div><div class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">                Message prevMsg = <span class="keyword">null</span>;</div><div class="line">                Message msg = mMessages;</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></div><div class="line">                   <span class="comment">// 如果从队列里拿到的msg是个“同步分割栏”，那么就寻找其后第一个“异步消息”</span></div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        prevMsg = msg;</div><div class="line">                        msg = msg.next;</div><div class="line">                    &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class="line">                        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">// Got a message.</span></div><div class="line">                        mBlocked = <span class="keyword">false</span>;</div><div class="line">                        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                            prevMsg.next = msg.next;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            mMessages = msg.next;</div><div class="line">                        &#125;</div><div class="line">                        msg.next = <span class="keyword">null</span>;</div><div class="line">                        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                        <span class="keyword">return</span> msg;</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// No more messages.</span></div><div class="line">                    nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Process the quit message now that all pending messages have been handled.</span></div><div class="line">                <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                    dispose();</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">              ......</div><div class="line">                </div><div class="line">            <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">            pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">            <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">            <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">            nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>调用这个方法的时候，有可能让线程进入等待状态。什么情况下线程会进入等待状态呢？有如下两种情况</p>
<ol>
<li>当消息队列中没有消息是，它会使线程进入等待状态</li>
<li>消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态</li>
</ol>
<p>消息队列中的消息是按照时间先后来排序的，后面我们在分析消息发送的时候会看到。</p>
<p>大家可能注意到如下一条native的语句，它是查看当前消息队列中有没有消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nativePollOnce(mPtr, nextPollTimeoutMillis);</div></pre></td></tr></table></figure>
<p>这是一个JNI方法，我们等一下再分析，这里传入的参数mPtr就是指向前面我们在JNI层创建的NativeMessageQueue对象了，而参数nextPollTimeoutMillis则表示如果当前消息队列中没有消息，它要等待的时候，for循环开始时，传入的值为0，表示不等待。</p>
<p>当前nativePoolOnce返回后，就去看看消息队列中有没有消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class="line">        nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Got a message.</span></div><div class="line">        mBlocked = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">        	prevMsg.next = msg.next;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">       		mMessages = msg.next;</div><div class="line">        &#125;</div><div class="line">        msg.next = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</div><div class="line">        <span class="keyword">return</span> msg;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// No more messages.</span></div><div class="line">    nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果消息队列中有消息，并且当前时候大于等于消息中的执行时间，那么就直接返回这个消息给Looper.loop消息处理，否则的话就要等待到消息的执行时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(when - now, Integer.MAX_VALUE);</div></pre></td></tr></table></figure>
<p>如果消息队列中没有消息，那就进入到无穷等待状态直到有新消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nextPollTimeoutMillis = -<span class="number">1</span>;</div></pre></td></tr></table></figure>
<p>-1表示下次调用nativePollOnce时，如果消息中没有消息就进入无限等待状态中去。这里计算出来的等待时间是在下次调用nativePollOnce的时候使用。</p>
<p> 这里说的等待，是空闲等待，而不是忙等待，因此，在进入空闲等待状态前，如果应用程序注册了IdleHandler接口来处理一些事情，那么就会先执行这里IdleHandler，然后再进入等待状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// If first time idle, then get the number of idlers to run.</span></div><div class="line"><span class="comment">// Idle handles only run if the queue is empty or if the first message</span></div><div class="line"><span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></div><div class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span>  &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">  	pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">  	<span class="comment">// No idle handlers to run.  Loop and wait some more.</span></div><div class="line">  	mBlocked = <span class="keyword">true</span>;</div><div class="line"> 	<span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">  	mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">&#125;</div><div class="line">mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div></pre></td></tr></table></figure>
<p>如果没有IdleHandler即pendingIdleHandlerCount等于0，那么下面的逻辑就不执行了，通过continue语句直接进入下一次循环，否则就把注册的mPendingIdleHandlers中的IdleHandler取出来，放到mPendingIdleHandler数组中，并循环执行这些注册了的IdelHandler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Run the idle handlers.</span></div><div class="line"><span class="comment">// We only ever reach this code block during the first iteration.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">    <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">    mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">   		 keep = idler.queueIdle();</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">    	 Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!keep) &#123;</div><div class="line">    	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    		mIdleHandlers.remove(idler);</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行完这些IdleHandler之后，下次再次调用nativePollOnce函数的时候，就不设置超时时间了，因为很有可能在执行IdleHandler的时候，已经有新的消息加入到消息队列中去了，因此，要重置nextPollTimeoutMillis的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line"><span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">nextPollTimeoutMillis = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>分析完MessageQueue的next方法之后，我们来稍微深入的分析下JNI方法nativePollOnce了，看看它是如何进入等待状态的，这个函数在<a href="http://androidxref.com/4.2_r1/xref/frameworks/base/core/jni/android_os_MessageQueue.cpp" target="_blank" rel="external">frameworks/base/core/jni/android_os_MessageQueue.cpp</a>文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></div><div class="line">        jint ptr, jint timeoutMillis) &#123;</div><div class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</div><div class="line">    nativeMessageQueue-&gt;pollOnce(env, timeoutMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> JNINativeMethod gMessageQueueMethods[] = &#123;</div><div class="line">    <span class="comment">/* name, signature, funcPtr */</span></div><div class="line">    &#123; <span class="string">"nativeInit"</span>, <span class="string">"()V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeInit &#125;,</div><div class="line">    &#123; <span class="string">"nativeDestroy"</span>, <span class="string">"()V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeDestroy &#125;,</div><div class="line">    &#123; <span class="string">"nativePollOnce"</span>, <span class="string">"(II)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativePollOnce &#125;,</div><div class="line">    &#123; <span class="string">"nativeWake"</span>, <span class="string">"(I)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeWake &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这个函数首先是通过传进来的参数ptr取回在Java层创建的MessageQueue对象时在JNI层创建的NativeMessageQueue对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></div><div class="line">  ....</div><div class="line">  	MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</div><div class="line">      mQuitAllowed = quitAllowed;</div><div class="line">      mPtr = nativeInit();</div><div class="line">   &#125;</div><div class="line">  .....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jobject obj)</span> </span>&#123;</div><div class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</div><div class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</div><div class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    nativeMessageQueue-&gt;incStrong(env);</div><div class="line">    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取到NativeMessageQueue对象，然后调用它的pollOnce函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, <span class="keyword">int</span> timeoutMillis) &#123;</div><div class="line">    mInCallback = <span class="literal">true</span>;</div><div class="line">    mLooper-&gt;pollOnce(timeoutMillis);</div><div class="line">    mInCallback = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</div><div class="line">        env-&gt;Throw(mExceptionObj);</div><div class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</div><div class="line">        mExceptionObj = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里把操作转给mLooper对象的pollOnce函数处理，这里的mLooer对象是C++层的对象，它也是在JNI层创建NativeMessageQueue对象时创建的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NativeMessageQueue::NativeMessageQueue() : mInCallback(<span class="literal">false</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</div><div class="line">    mLooper = Looper::getForThread();</div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</div><div class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</div><div class="line">        Looper::setForThread(mLooper);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它的pollOnce函数在Looper.cpp(<a href="http://androidxref.com/4.2_r1/xref/frameworks/native/libs/utils/Looper.cpp" target="_blank" rel="external">JellyBean</a>、<a href="http://androidxref.com/5.0.0_r2/xref/system/core/libutils/Looper.cpp" target="_blank" rel="external">Lollipop</a>)中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        ....</div><div class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</div><div class="line">			.....</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        result = pollInner(timeoutMillis);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们只看核心部分，这里主要是继续调用pollInner函数来进一步操作，如果pollInner返回不等于0，这个函数就可以返回了。</p>
<p>pollInner的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;</div><div class="line">	.....</div><div class="line"></div><div class="line">    <span class="comment">// Poll.</span></div><div class="line">    <span class="keyword">int</span> result = ALOOPER_POLL_WAKE;</div><div class="line">    mResponses.clear();</div><div class="line">    mResponseIndex = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> epoll_event eventItems[EPOLL_MAX_EVENTS];</div><div class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</div><div class="line"></div><div class="line">    <span class="comment">// Acquire lock.</span></div><div class="line">    mLock.lock();</div><div class="line"></div><div class="line">    <span class="comment">// Check for poll error.</span></div><div class="line">    <span class="keyword">if</span> (eventCount &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</div><div class="line">            <span class="keyword">goto</span> Done;</div><div class="line">        &#125;</div><div class="line">        ALOGW(<span class="string">"Poll failed with an unexpected error, errno=%d"</span>, errno);</div><div class="line">        result = ALOOPER_POLL_ERROR;</div><div class="line">        <span class="keyword">goto</span> Done;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Check for poll timeout.</span></div><div class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;</div><div class="line">		.....</div><div class="line">        result = ALOOPER_POLL_TIMEOUT;</div><div class="line">        <span class="keyword">goto</span> Done;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	.....</div><div class="line">      </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</div><div class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</div><div class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</div><div class="line">        <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;</div><div class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</div><div class="line">                awoken();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">           .....</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">Done: ;</div><div class="line"></div><div class="line">    <span class="comment">// Invoke pending message callbacks.</span></div><div class="line">    mNextMessageUptime = LLONG_MAX;</div><div class="line">    <span class="keyword">while</span> (mMessageEnvelopes.size() != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</div><div class="line">        <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</div><div class="line">            <span class="comment">// Remove the envelope from the list.</span></div><div class="line">            <span class="comment">// We keep a strong reference to the handler until the call to handleMessage</span></div><div class="line">            <span class="comment">// finishes.  Then we drop it so that the handler can be deleted *before*</span></div><div class="line">            <span class="comment">// we reacquire our lock.</span></div><div class="line">            &#123; <span class="comment">// obtain handler</span></div><div class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</div><div class="line">                Message message = messageEnvelope.message;</div><div class="line">                mMessageEnvelopes.removeAt(<span class="number">0</span>);</div><div class="line">                mSendingMessage = <span class="literal">true</span>;</div><div class="line">                mLock.unlock();</div><div class="line"></div><div class="line">				....</div><div class="line">                handler-&gt;handleMessage(message);</div><div class="line">            &#125; <span class="comment">// release handler</span></div><div class="line"></div><div class="line">            mLock.lock();</div><div class="line">            mSendingMessage = <span class="literal">false</span>;</div><div class="line">            result = ALOOPER_POLL_CALLBACK;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// The last message left at the head of the queue determines the next wakeup time.</span></div><div class="line">            mNextMessageUptime = messageEnvelope.uptime;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Release lock.</span></div><div class="line">    mLock.unlock();</div><div class="line"></div><div class="line">    <span class="comment">// Invoke all response callbacks.</span></div><div class="line">   ......</div><div class="line">     </div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数比较长并且其中用到了goto，我们仍然只关注核心代码，我们看到函数开头首先是调用epoll_wait函数来看看epoll专用文件描述符mEpollFd所监控的文件描述符是否有IO事件发生，它设置监控的超时时间为pollOnce函数传递过来的timeoutMillis：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</div></pre></td></tr></table></figure>
<p>当mEpollFd所监控的文件描述符发生了要监控的IO事件后或者监控时间超时后，线程就从epoll_wait返回了，否则线程就会在epoll_wait函数中进入睡眠状态了。返回后如果eventCount等于0，就说明是超时了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;  </div><div class="line">    ......  </div><div class="line">    result = ALOOPER_POLL_TIMEOUT;  </div><div class="line">    <span class="keyword">goto</span> Done;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果eventCount不等于0，就说明发生要监控的事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</div><div class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</div><div class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</div><div class="line">        <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;</div><div class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</div><div class="line">                awoken();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">           .....</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里我们只关注mWakeReadPipeFd文件描述符上的事件, 在Looper的构造函数中设置了要监控mWakeReadPipeFd文件描述符的EPOLLIN事件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :</div><div class="line">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(<span class="literal">false</span>),</div><div class="line">        mResponseIndex(<span class="number">0</span>), mNextMessageUptime(LLONG_MAX) &#123;</div><div class="line">    <span class="keyword">int</span> wakeFds[<span class="number">2</span>];</div><div class="line">    <span class="keyword">int</span> result = pipe(wakeFds); <span class="comment">// 创建一个管道</span></div><div class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</div><div class="line"></div><div class="line">    mWakeReadPipeFd = wakeFds[<span class="number">0</span>];   <span class="comment">// 管道的“读取端”</span></div><div class="line">    mWakeWritePipeFd = wakeFds[<span class="number">1</span>];  <span class="comment">// 管道的“写入端”</span></div><div class="line"></div><div class="line">    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</div><div class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,</div><div class="line">            errno);</div><div class="line"></div><div class="line">    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</div><div class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,</div><div class="line">            errno);</div><div class="line"></div><div class="line">    <span class="comment">// Allocate the epoll instance and register the wake pipe.</span></div><div class="line">    <span class="comment">// 创建一个epoll</span></div><div class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT);</div><div class="line">    LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> epoll_event eventItem;</div><div class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></div><div class="line">   </div><div class="line">    eventItem.events = EPOLLIN;</div><div class="line">    eventItem.data.fd = mWakeReadPipeFd;</div><div class="line">    <span class="comment">// 监听管道的read端</span></div><div class="line">    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem);</div><div class="line">    LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,errno);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在mWakeReadPipeFd文件描述符上发生了EPOLLIN就说明应用程序中的消息队列里面有新的消息需要处理了，接下来它就会先调用awoken函数清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。</p>
<p>awoken函数的实现很简单，它就是把管道中的内容都读取出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Looper::awoken() &#123;</div><div class="line">	.....</div><div class="line">    <span class="keyword">char</span> buffer[<span class="number">16</span>];</div><div class="line">    <span class="keyword">ssize_t</span> nRead;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        nRead = read(mWakeReadPipeFd, buffer, <span class="keyword">sizeof</span>(buffer));</div><div class="line">    &#125; <span class="keyword">while</span> ((nRead == <span class="number">-1</span> &amp;&amp; errno == EINTR) || nRead == <span class="keyword">sizeof</span>(buffer));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为当其它的线程向应用程序的消息队列加入新的消息时，会向这个管道写入新的内容来通知应用程序主线程有新的消息需要处理了，下面我们分析消息的发送的时候将会看到。</p>
<p> 这样，消息的循环过程就分析完了，这部分逻辑还是比较复杂的，它利用Linux系统中的管道（pipe）进程间通信机制来实现消息的等待和处理，不过，了解了这部分内容之后，下面我们分析消息的发送和处理就简单多了。</p>
<h4 id="3-消息发送"><a href="#3-消息发送" class="headerlink" title="3. 消息发送"></a>3. 消息发送</h4><p>在线程(不管是UI线程还是子线程)中准备好消息队列并且进入消息循环后，其他地方就可以往这个消息队列中发送消息了。</p>
<p>在前面我们提到过Handler的构造方法，主要就是初始化类成员mLooper和mQueue。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;  </div><div class="line">        ......  </div><div class="line">  </div><div class="line">        mLooper = Looper.myLooper();  </div><div class="line">        ......  </div><div class="line">  </div><div class="line">        mQueue = mLooper.mQueue;  </div><div class="line">        ......  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">  </div><div class="line">    <span class="keyword">final</span> MessageQueue mQueue;  </div><div class="line">    <span class="keyword">final</span> Looper mLooper;  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有了Looper对象后，就可以通过mLooper.mQueue来访问消息队列了。发送消息的方法大家都不陌生，就是常用的sendMessage方法。在发送消息时，是可以指定消息的处理时间的，但是通过sendMessage函数发送的消息的处理时间默认就为当前时间，即表示要马上处理，因此，从sendMessage函数中调用sendMessageDelayed函数，传入的时间参数为0，表示这个消息不要延时处理，而在sendMessageDelayed函数中，则会先获得当前时间，然后加上消息要延时处理的时间，即得到这个处理这个消息的绝对时间，然后调用sendMessageAtTime函数来把消息加入到应用程序的消息队列中去。</p>
<p> 在sendMessageAtTime函数，首先得到应用程序的消息队列mQueue，这是在Handler对象构造时初始化好的，前面已经分析过了，接着设置这个消息的目标对象target，即这个消息最终是由谁来处理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">       MessageQueue queue = mQueue;</div><div class="line">       <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">           RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                   <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">           Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">       msg.target = <span class="keyword">this</span>;</div><div class="line">       <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">           msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这里将它赋值为this，即表示这个消息最终由这个Handler对象来处理。</p>
<p>函数最后调用queue.enqueueMessage来把这个消息加入到消息队列中，具体实现在<a href="http://androidxref.com/4.2_r1/xref/frameworks/base/core/java/android/os/MessageQueue.java" target="_blank" rel="external">MessageQueue.java</a>文件中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> needWake;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">       .......</div><div class="line"></div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">          <span class="comment">// 此时，新消息会插入到链表的表头，这意味着队列需要调整唤醒时间啦。</span></div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></div><div class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></div><div class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></div><div class="line">          <span class="comment">// 此时，新消息会插入到链表的内部，一般情况下，这不需要调整唤醒时间。</span></div><div class="line">          <span class="comment">// 但还必须考虑到当表头为“同步分隔栏”的情况</span></div><div class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                  <span class="comment">// 说明即便msg是异步的，也不是链表中第一个异步消息，所以没必要唤醒了</span></div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (needWake) &#123;</div><div class="line">        nativeWake(mPtr);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这段代码来看MessageQueue说是一个消息队列，但它其实不是队列，而是一个链表。</p>
<p>把消息加入到消息队列时，分两种情况，一种当前消息队列为空时，这时候线程一般就是处于空闲等待状态了，这时候就要唤醒它，另一种情况是消息队列不为空，这时候就不需要唤醒线程了，因为这时候它一定是在忙着处于消息队列中的消息，因此不会处于空闲等待的状态。</p>
<p>第一种情况比较简单，只要把消息放在消息队列头就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">msg.next = p;  </div><div class="line">mMessages = msg;  </div><div class="line">needWake = mBlocked;</div></pre></td></tr></table></figure>
<p> 第二种情况相对就比较复杂一些了，前面我们说过，当往消息队列中发送消息时，是可以指定消息的处理时间的，而消息队列中的消息，就是按照这个时间从小到大来排序的，因此，当把新的消息加入到消息队列时，就要根据它的处理时间来找到合适的位置，然后再放进消息队列中去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Message prev;</div><div class="line"><span class="keyword">for</span> (;;) &#123;</div><div class="line">  prev = p;</div><div class="line">  p = p.next;</div><div class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">    needWake = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">prev.next = msg;</div></pre></td></tr></table></figure>
<p>把消息加入到消息队列去后，如果线程正处于空闲等待状态，就需要调用natvieWake函数来唤醒它了，这是一个JNI方法，定义在<a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/jni/android_os_MessageQueue.cpp" target="_blank" rel="external">android_os_MessageQueue.cpp</a>文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</div><div class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</div><div class="line">    <span class="keyword">return</span> nativeMessageQueue-&gt;wake();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个JNI层的NativeMessageQueue对象我们在前面分析消息循环的时候创建好的，保存在Java层的MessageQueue对象的mPtr成员变量中，这里把它取回来之后，就调用它的wake函数来唤醒关联的线程，wake方法也在<a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/jni/android_os_MessageQueue.cpp" target="_blank" rel="external">android_os_MessageQueue.cpp</a>文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> NativeMessageQueue::wake() &#123;</div><div class="line">    mLooper-&gt;wake();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这里它又通过成员变量mLooper的wake函数来执行操作，这里的mLooper成员变量是一个C++层实现的Looper对象，它定义在<a href="http://androidxref.com/5.0.0_r2/xref/system/core/libutils/Looper.cpp" target="_blank" rel="external">Looper.cpp</a>文件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Looper::wake() &#123;</div><div class="line">	......</div><div class="line">    <span class="keyword">ssize_t</span> nWrite;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        nWrite = write(mWakeWritePipeFd, <span class="string">"W"</span>, <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</div><div class="line"></div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这个wake函数很简单，只是通过打开文件描述符mWakeWritePipeFd往管道的写入一个”W”字符串。其实，往管道写入什么内容并不重要，往管道写入内容的目的是为了唤醒关联的线程。前面我们在分析应用程序的消息循环时说到，当消息队列中没有消息处理时，关联的线程就会进入空闲等待状态，而这个空闲等待状态就是通过调用这个Looper类的pollInner函数来进入的，具体就是在pollInner函数中调用epoll_wait函数来等待管道中有内容可读的。</p>
<p>这时候既然管道中有内容可读了，关联的线程就会从这里的Looper类的pollInner函数返回到JNI层的nativePollOnce函数，最后返回到Java层中的MessageQueue.next方法中去，这里它就会发现消息队列中有新的消息需要处理了，于就会处理这个消息。</p>
<h4 id="4-消息处理"><a href="#4-消息处理" class="headerlink" title="4. 消息处理"></a>4. 消息处理</h4><p>前面第一部分分析消息循环时，在Looper类的looper方法中进行消息循环的，这个方法中从消息队列中获取到消息对象msg后，就会调用它的target成员变量的dispatchMessage方法来处理这个消息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    	......</div><div class="line">      <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line">......</div><div class="line">      <span class="keyword">for</span> (;;) &#123;</div><div class="line">          Message msg = queue.next(); <span class="comment">// might block</span></div><div class="line">          </div><div class="line">        	.......</div><div class="line">            </div><div class="line">          msg.target.dispatchMessage(msg);</div><div class="line"></div><div class="line">          ......</div><div class="line"></div><div class="line">          msg.recycleUnchecked();</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>在前面分析消息的发送时说过，这个消息对象msg的成员变量target是在发送消息的时候设置好的，通过哪个Handler来发送消息，就通过哪个Handler来处理消息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">            handleCallback(msg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            handleMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的消息对象msg的callback成员变量和Handler类的mCallBack成员变量一般都为null，于是，就会调用Handler类的handleMessage方法来处理这个消息，这就到了我们平常使用Handler的时候重写的Handler的方法handlerMessage。</p>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p> 至此，我们就从消息循环、消息发送和消息处理三个部分分析完Android应用程序的消息处理机制了，为了更深理解，这里我们对其中的一些要点作一个总结：</p>
<ul>
<li>Android应用程序的消息处理机制由消息循环、消息发送和消息处理三个部分组成的。</li>
<li>Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。</li>
<li>Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说就是是通过Linux系统的Epoll机制中的epoll_wait函数进行的。</li>
<li>当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。</li>
<li>当应用程序主线程在进入空闲等待前，会认为当前线程处理空闲状态，于是就会调用那些已经注册了的IdleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。</li>
</ul>
<p>​    </p>
<h4 id="6-问题"><a href="#6-问题" class="headerlink" title="6. 问题"></a>6. 问题</h4><p>最后，在前面的Looper部分相信很多人有个疑问</p>
<ul>
<li>sThreadLocal在Looper类中是静态的，为什么线程A中已经调用了Looper.prepare给sThreadLocal设置了值，在线程B中直接调用Looper.myLooper从sThreadLocal中get值返回确是null？</li>
<li>一个线程可以有几个Handler？</li>
<li>一个线程可以有几个Looper？</li>
</ul>
<h4 id="7-补充内容"><a href="#7-补充内容" class="headerlink" title="7. 补充内容"></a>7. 补充内容</h4><h5 id="7-1-ThreadLocal"><a href="#7-1-ThreadLocal" class="headerlink" title="7.1 ThreadLocal"></a>7.1 ThreadLocal</h5><p>官方文档中对ThreadLocal的说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Implements a thread-local storage, that is, a variable for which each thread</div><div class="line"> * has its own value. All threads share the same &#123;<span class="doctag">@code</span> ThreadLocal&#125; object,</div><div class="line"> * but each sees a different value when accessing it, and changes made by one</div><div class="line"> * thread do not affect the other threads. The implementation supports</div><div class="line"> * &#123;<span class="doctag">@code</span> null&#125; values.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@see</span> java.lang.Thread</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段话的意思是实现了一个线程相关的存储，即每个线程都有自己独立的变量。所有的线程都共享者这一个<code>ThreadLocal</code>对象，并且当一个线程的值发生改变之后，不会影响其他的线程的值。</p>
<p>ThreadLocal的类定义使用了泛型<code>ThreadLocal&lt;T&gt;</code>，其中T指代的是在线程中存取值的类型。（对应Android中使用的ThreadLocal, T则存放的类型为Looper）</p>
<ul>
<li>set方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Sets the value of this variable for the current thread. If set to</div><div class="line"> * &#123;<span class="doctag">@code</span> null&#125;, the value will be set to null and the underlying entry will</div><div class="line"> * still be present.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> value the new value of the variable for the caller thread.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread currentThread = Thread.currentThread();</div><div class="line">    Values values = values(currentThread);</div><div class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</div><div class="line">        values = initializeValues(currentThread);</div><div class="line">    &#125;</div><div class="line">    values.put(<span class="keyword">this</span>, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Sets entry for given ThreadLocal to given value, creating an</div><div class="line"> * entry if necessary.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line">  cleanUp();</div><div class="line"></div><div class="line">  <span class="comment">// Keep track of first tombstone. That's where we want to go back</span></div><div class="line">  <span class="comment">// and add an entry if necessary.</span></div><div class="line">  <span class="keyword">int</span> firstTombstone = -<span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> index = key.hash &amp; mask;; index = next(index)) &#123;</div><div class="line">    Object k = table[index];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (k == key.reference) &#123;</div><div class="line">      <span class="comment">// Replace existing entry.</span></div><div class="line">      table[index + <span class="number">1</span>] = value;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// Fill in null slot.</span></div><div class="line">        table[index] = key.reference;</div><div class="line">        table[index + <span class="number">1</span>] = value;</div><div class="line">        size++;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// Go back and replace first tombstone.</span></div><div class="line">      table[firstTombstone] = key.reference;</div><div class="line">      table[firstTombstone + <span class="number">1</span>] = value;</div><div class="line">      tombstones--;</div><div class="line">      size++;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Remember first tombstone.</span></div><div class="line">    <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span> &amp;&amp; k == TOMBSTONE) &#123;</div><div class="line">      firstTombstone = index;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单地说，每个线程对象内部会记录一张逻辑上的key-value表，当我们在不同Thread里调用Looper.prepare()时，其实是向Thread对应的那张表里添加一个key-value项，其中的key部分，指向的是同一个对象，即Looper.sThreadLocal静态对象，而value部分，则彼此不同，我们可以画出如下示意图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7u2jwu.com1.z0.glb.clouddn.com/android/handler/ThreadLocal.png" alt="ThreadLocal示意图" title="">
                </div>
                <div class="image-caption">ThreadLocal示意图</div>
            </figure>
<p>看到了吧，不同Thread会对应不同Object[]数组，该数组以每2个元素为一个key-value对。请注意不同Thread虽然使用同一个静态对象作为key值，最终却会对应不同的Looper对象。</p>
<h5 id="7-2-同步分隔栏"><a href="#7-2-同步分隔栏" class="headerlink" title="7.2 同步分隔栏"></a>7.2 同步分隔栏</h5><p>上面的代码中还有一个“同步分割栏”的概念需要提一下。所谓“同步分割栏”，可以被理解为一个特殊Message，它的target域为null。它不能通过sendMessageAtTime()等函数加入消息队列里，而只能通过调用Looper的postSyncBarrier()来加入消息队列。</p>
<p>“同步分割栏”是起什么作用的呢？它就像一个卡子，卡在消息链表中的某个位置，当消息循环不断从消息链表中摘取消息并进行处理时，一旦遇到这种“同步分割栏”，那么即使在分割栏之后还有若干已经到时的普通Message，也不会摘取这些消息了。请注意，此时只是不会摘取“普通Message”了，如果队列中还设置有“异步Message”，那么还是会摘取已到时的“异步Message”的。</p>
<p>在Android的消息机制里，“普通Message”和“异步Message”也就是这点儿区别啦，也就是说，如果消息列表中根本没有设置“同步分割栏”的话，那么“普通Message”和“异步Message”的处理就没什么大的不同了。</p>
<p>打入“同步分割栏”的postSyncBarrier()函数的代码如下：<br><a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/java/android/os/Looper.java" target="_blank" rel="external">frameworks/base/core/java/android/os/Looper.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mQueue.enqueueSyncBarrier(SystemClock.uptimeMillis());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/java/android/os/MessageQueue.java" target="_blank" rel="external">frameworks/base/core/java/android/os/MessageQueue.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">enqueueSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</div><div class="line">        <span class="keyword">final</span> Message msg = Message.obtain();</div><div class="line">        msg.when = when;</div><div class="line">        msg.arg1 = token;</div><div class="line"></div><div class="line"></div><div class="line">        Message prev = <span class="keyword">null</span>;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; </div><div class="line">            msg.next = p;</div><div class="line">            prev.next = msg;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> token;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要得到“异步Message”，只需调用一下Message的setAsynchronous()即可：<br><a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/java/android/os/Message.java" target="_blank" rel="external">frameworks/base/core/java/android/os/Message.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsynchronous</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (async) &#123;</div><div class="line">        flags |= FLAG_ASYNCHRONOUS;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        flags &amp;= ~FLAG_ASYNCHRONOUS;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般，我们是通过“异步Handler”向消息队列打入“异步Message”的。异步Handler的mAsynchronous域为true，因此它在调用enqueueMessage()时，可以走入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">    msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们画一张关于“同步分割栏”的示意图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7u2jwu.com1.z0.glb.clouddn.com/android/handler/handler-async.png" alt="img" title="">
                </div>
                <div class="image-caption">img</div>
            </figure>
<p>图中的消息队列中有一个“同步分割栏”，因此它后面的“2”号Message即使到时了，也不会摘取下来。而“3”号Message因为是个异步Message，所以当它到时后，是可以进行处理的。</p>
<p>“同步分割栏”这种卡子会一直卡在消息队列中，除非我们调用removeSyncBarrier()删除这个卡子。<br><a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/java/android/os/Looper.java" target="_blank" rel="external">frameworks/base/core/java/android/os/Looper.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</div><div class="line">    mQueue.removeSyncBarrier(token);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/java/android/os/MessageQueue.java" target="_blank" rel="external">frameworks/base/core/java/android/os/MessageQueue.java</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</div><div class="line">    <span class="comment">// Remove a sync barrier token from the queue.</span></div><div class="line">    <span class="comment">// If the queue is no longer stalled by a barrier then wake it.</span></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        Message prev = <span class="keyword">null</span>;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</div><div class="line">            prev = p;</div><div class="line">            p = p.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The specified message queue synchronization "</span></div><div class="line">                    + <span class="string">" barrier token has not been posted or has already been removed."</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</div><div class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</div><div class="line">            prev.next = p.next;</div><div class="line">            needWake = <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            mMessages = p.next;</div><div class="line">            needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        p.recycle();</div><div class="line"></div><div class="line">        <span class="comment">// If the loop is quitting then it is already awake.</span></div><div class="line">        <span class="comment">// We can assume mPtr != 0 when mQuitting is false.</span></div><div class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和插入消息类似，如果删除动作改变了链表的头部，也意味着队列的最近唤醒时间应该被调整了，因此needWake会被设为true，以便代码下方可以走进nativeWake()。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="http://blog.csdn.net/luoshengyang/article/details/6817933" target="_blank" rel="external">Android应用程序消息处理机制（Looper、Handler）分析</a></p>
<p><a href="https://my.oschina.net/youranhongcha/blog/492591" target="_blank" rel="external">聊一聊Android的消息机制</a></p>
<p><a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="external">Android消息机制2-Handler(Native层)</a></p>
<h4 id="相关源码"><a href="#相关源码" class="headerlink" title="相关源码"></a>相关源码</h4><p><a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/java/android/os/Handler.java" target="_blank" rel="external">Handler.java</a></p>
<p><a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/java/android/os/Looper.java" target="_blank" rel="external">Looper.java</a></p>
<p><a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/java/android/os/MessageQueue.java" target="_blank" rel="external">MessageQueue.java</a></p>
<p><a href="http://androidxref.com/5.0.0_r2/xref/frameworks/base/core/java/android/os/Message.java" target="_blank" rel="external">Message.java</a></p>
<p><a href="http://androidxref.com/5.0.0_r2/xref/system/core/libutils/Looper.cpp" target="_blank" rel="external">Looper.cpp</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。&quot;&gt;&lt;a href=&quot;#Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于
    
    </summary>
    
      <category term="Android" scheme="http://jasonzhang1986.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://jasonzhang1986.github.io/2017/03/07/hello-world/"/>
    <id>http://jasonzhang1986.github.io/2017/03/07/hello-world/</id>
    <published>2017-03-07T09:45:43.459Z</published>
    <updated>2017-03-07T09:45:43.466Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
