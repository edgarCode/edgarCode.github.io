<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonZhang&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-10T10:21:41.129Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JasonZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聊一聊Android的消息机制</title>
    <link href="http://yoursite.com/2017/03/10/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/03/10/消息机制/</id>
    <published>2017-03-10T09:37:59.736Z</published>
    <updated>2017-03-10T10:21:41.129Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一、Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。"><a href="#一、Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。" class="headerlink" title="一、Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。"></a>一、Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。</h5><p>今天我们主要来聊一聊进程内部的消息机制<strong>Handler</strong>。</p>
<p>从技术实现来说消息机制并不复杂，不只是Android平台,各种平台的消息机制原理基本上都是比较相似的，其中用到的主要概念有：</p>
<ol>
<li>消息发送者</li>
<li>消息队列</li>
<li>消息循环处理</li>
</ol>
<p>简单示意图如下：</p>
<p><img src="http://7u2jwu.com1.z0.glb.clouddn.com/android/handler/xiaoxi01.png" alt="image"></p>
<p>图中表达的意思是，消息发送者通过某种方式将消息发送到消息队列中，同时还有一个消息处理循环，不断从消息队列里取消息，并进行处理。</p>
<p>Android的消息机制主要是指Handler的运行机制，Hander的运行需要相关的MessageQueue和Looper的支撑。图中右侧的部分可以理解为Android中的Looper类，这个类的内部有对应的消息队列(MessageQueue mQueue)和loop方法(取消息的循环)</p>
<p>从我们开发者的角度来说，Handler是Android消息机制的最上层接口，这使得我们在开发过程中绝大多数情况下只需要和Handler打交道就可以，Handler的使用方法也很简单，我们常常在子线程中需要更新UI时使用，常见代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">private Handler handler = new Handler()&#123;</div><div class="line">    @Override public void handleMessage(Message msg) &#123;</div><div class="line">      super.handleMessage(msg);</div><div class="line">      switch (msg.what) &#123;</div><div class="line">        case xxx:</div><div class="line">          ...</div><div class="line">          updateUI();</div><div class="line">          break;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  ....</div><div class="line">  </div><div class="line">  private void threadMethod() &#123;</div><div class="line">    new Thread()&#123;</div><div class="line">      @Override public void run() &#123;</div><div class="line">        super.run();</div><div class="line">        ...</div><div class="line">        handler.sendMessage(msg);</div><div class="line">        ...</div><div class="line">      &#125;</div><div class="line">    &#125;.start();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  //在子线程中使用Handler</div><div class="line">   class LooperThread extends Thread &#123;</div><div class="line">        public Handler mHandler;</div><div class="line">  </div><div class="line">        public void run() &#123;</div><div class="line">            Looper.prepare();</div><div class="line">  </div><div class="line">            mHandler = new Handler() &#123;</div><div class="line">                public void handleMessage(Message msg) &#123;</div><div class="line">                    // process incoming messages here</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">  </div><div class="line">            Looper.loop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从实例代码中我们看到消息机制三步中消息发送(sendMessage)，那另外两步(消息循环和消息处理)在哪里呢？我们跟踪进入Handler的源码中看一看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public Handler() &#123;</div><div class="line">    this(null, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Handler(Looper looper) &#123;</div><div class="line">    this(looper, null, false);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">    if (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        final Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</div><div class="line">            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    if (mLooper == null) &#123;</div><div class="line">        throw new RuntimeException(</div><div class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从Handler的构造方法中看，我们使用默认的构造方法使用的Looper是通过Looper.myLooper()获取到的，紧接着一行有判断mLooper==null时抛出一个RuntimeException，意思是在没有调用Looper.prepare()方法时是不能在Thread中创建Handler对象的，这里有个问题，我们在Activity(UI线程)中new Handler的时候也没有看到调用Looper.prepare()方法，为什么没有抛出这个RuntimeException呢？</p>
<p>你是不是觉得系统在Looper.myLooper()中做了什么操作？那我们来继续跟进去看看Looper.myLooper()都做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Return the Looper object associated with the current thread.  Returns</div><div class="line"> * null if the calling thread is not associated with a Looper.</div><div class="line"> */</div><div class="line">public static Looper myLooper() &#123;</div><div class="line">    return sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>奇怪，这里只是调用了sThreadLocal的get方法获取了Looper对象并返回，并没有调用Looper.prepare(),那为什么不会抛异常呢？是因为UI线程特殊吗？？</p>
<p>答案显然不是，了解应用启动流程的应该知道，应用的main方法在ActivityThread中，在main方法中完成了一些初始化工作，我们来看main方法中做了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">  </div><div class="line">  ...</div><div class="line">  </div><div class="line">  Looper.prepareMainLooper();</div><div class="line">  ActivityThread thread = new ActivityThread();</div><div class="line">  thread.attach(false);</div><div class="line">  if(sMainThreadHandler == null) &#123;</div><div class="line">    sMainThreadHandler = thread.getHandler();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line">  </div><div class="line">  Looper.loop();</div><div class="line">  throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到在main中有调用Looper.prepareMainLooper(),跟进去看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public static void prepareMainLooper() &#123;</div><div class="line">  prepare(false);</div><div class="line">  Class var0 = Looper.class;</div><div class="line">  synchronized(Looper.class) &#123;</div><div class="line">    if(sMainLooper != null) &#123;</div><div class="line">      throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">      sMainLooper = myLooper();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void prepare() &#123;</div><div class="line">  prepare(true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">  if(sThreadLocal.get() != null) &#123;</div><div class="line">    throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">  &#125; else &#123;</div><div class="line">    sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到prepareMainLooper()和prepare()调用的是Looper的同一个方法prepard(boolean quitAllowed)，UI线程的Looper是不允许退出的(如果允许退出，调用了quit岂不UI就无法刷新啦)，其他线程的Looper是允许退出的。</p>
<p>prepare方法调用后，创建Handler,这里是new ActivityThread对象，ActivityThread有实例变量mH就是Handler的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">main() &#123;</div><div class="line">    ...</div><div class="line">    ActivityThread thread = new ActivityThread();</div><div class="line">    </div><div class="line">    if(sMainThreadHandler == null) &#123;</div><div class="line">        sMainThreadHandler = thread.getHandler();</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"> </div><div class="line">final ActivityThread.H mH = new ActivityThread.H(null);</div><div class="line"></div><div class="line">final Handler getHandler() &#123;</div><div class="line">    return this.mH;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">private class H extends Handler &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里<strong>Looper</strong>和<strong>Handler</strong>都准备好，开始消息循环<strong>Looper.loop()</strong>。aaaa</p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一、Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。&quot;&gt;&lt;a href=&quot;#一、Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/03/07/hello-world/"/>
    <id>http://yoursite.com/2017/03/07/hello-world/</id>
    <published>2017-03-07T09:45:43.459Z</published>
    <updated>2017-03-07T09:45:43.466Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
