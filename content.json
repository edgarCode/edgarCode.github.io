{"meta":{"title":"JasonZhang's Blog","subtitle":null,"description":null,"author":"JasonZhang","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-03-10T10:18:27.000Z","updated":"2017-03-10T10:18:27.258Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"聊一聊Android的消息机制","slug":"Handler","date":"2017-03-10T09:37:59.736Z","updated":"2017-03-14T09:38:51.373Z","comments":true,"path":"2017/03/10/Handler/","link":"","permalink":"http://yoursite.com/2017/03/10/Handler/","excerpt":"","text":"一、Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。今天我们主要来聊一聊进程内部的消息机制Handler。 从技术实现来说消息机制并不复杂，不只是Android平台,各种平台的消息机制原理基本上都是比较相似的，其中用到的主要概念有： 消息发送者 消息队列 消息循环处理 简单示意图如下： image 图中表达的意思是，消息发送者通过某种方式将消息发送到消息队列中，同时还有一个消息处理循环，不断从消息队列里取消息，并进行处理。 Android的消息机制主要是指Handler的运行机制，Hander的运行需要相关的MessageQueue和Looper的支撑。图中右侧的部分可以理解为Android中的Looper类，这个类的内部有对应的消息队列(MessageQueue mQueue)和loop方法(取消息的循环) 从我们开发者的角度来说，Handler是Android消息机制的最上层接口，这使得我们在开发过程中绝大多数情况下只需要和Handler打交道就可以，Handler的使用方法也很简单，我们常常在子线程中需要更新UI时使用，常见代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case xxx: ... updateUI(); break; &#125; &#125; &#125;; .... private void threadMethod() &#123; new Thread()&#123; @Override public void run() &#123; super.run(); ... handler.sendMessage(msg); ... &#125; &#125;.start(); &#125; //在子线程中使用Handler class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125; &#125; 从实例代码中我们看到消息机制三步中消息发送(sendMessage)，那另外两步(消息循环和消息处理)在哪里呢？我们跟踪进入Handler的源码中看一看123456789101112131415161718192021222324252627public Handler() &#123; this(null, false);&#125;public Handler(Looper looper) &#123; this(looper, null, false);&#125;public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 从Handler的构造方法中看，我们使用默认的构造方法使用的Looper是通过Looper.myLooper()获取到的，紧接着一行有判断mLooper==null时抛出一个RuntimeException，意思是在没有调用Looper.prepare()方法时是不能在Thread中创建Handler对象的，这里有个问题，我们在Activity(UI线程)中new Handler的时候也没有看到调用Looper.prepare()方法，为什么没有抛出这个RuntimeException呢？ 你是不是觉得系统在Looper.myLooper()中做了什么操作？那我们来继续跟进去看看Looper.myLooper()都做了什么。1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static Looper myLooper() &#123; return sThreadLocal.get();&#125; 奇怪，这里只是调用了sThreadLocal的get方法获取了Looper对象并返回，并没有调用Looper.prepare(),那为什么不会抛异常呢？是因为UI线程特殊吗？？ 答案显然不是，了解应用启动流程的应该知道，应用的main方法在ActivityThread中，在main方法中完成了一些初始化工作，我们来看main方法中做了什么12345678910111213141516public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if(sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ... Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 我们看到在main中有调用Looper.prepareMainLooper(),跟进去看1234567891011121314151617181920212223public static void prepareMainLooper() &#123; prepare(false); Class var0 = Looper.class; synchronized(Looper.class) &#123; if(sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; else &#123; sMainLooper = myLooper(); &#125; &#125;&#125;public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if(sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; else &#123; sThreadLocal.set(new Looper(quitAllowed)); &#125;&#125; 可以看到prepareMainLooper()和prepare()调用的是Looper的同一个方法prepard(boolean quitAllowed)，UI线程的Looper是不允许退出的(如果允许退出，调用了quit岂不UI就无法刷新啦)，其他线程的Looper是允许退出的。 prepare方法调用后，创建Handler,这里是new ActivityThread对象，ActivityThread有实例变量mH就是Handler的对象12345678910111213141516171819202122main() &#123; ... ActivityThread thread = new ActivityThread(); if(sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ...&#125; final ActivityThread.H mH = new ActivityThread.H(null);final Handler getHandler() &#123; return this.mH;&#125;...private class H extends Handler &#123; ...&#125; 到这里Looper和Handler都准备好，开始消息循环Looper.loop()。 12345678910111213141516171819202122232425262728/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; ... for (;;) &#123; //永久循环 Message msg = queue.next(); // might block if (msg == null) &#123; //死循环退出条件 // No message indicates that the message queue is quitting. return; &#125; ... msg.target.dispatchMessage(msg);//这里的target是Handler ... &#125; &#125; 说到消息的循环，就不得不提MessageQueue中next方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; ...... nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; ...... // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 调用这个方法的时候，有可能让线程进入等待状态。什么情况下线程会进入等待状态呢？有如下两种情况 当消息队列中没有消息是，它会使线程进入等待状态 消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态 消息队列中的消息是按照时间先后来排序的，后面我们在分析消息发送的时候会看到。 大家可能注意到如下一条native的语句，它是查看当前消息队列中有没有消息： 1nativePollOnce(mPtr, nextPollTimeoutMillis); 这是一个JNI方法，我们等一下再分析，这里传入的参数mPtr就是指向前面我们在JNI层创建的NativeMessageQueue对象了，而参数nextPollTimeoutMillis则表示如果当前消息队列中没有消息，它要等待的时候，for循环开始时，传入的值为0，表示不等待。 当前nativePoolOnce返回后，就去看看消息队列中有没有消息： 1234567891011121314151617181920if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg); return msg; &#125;&#125; else &#123; // No more messages. nextPollTimeoutMillis = -1;&#125; 如果消息队列中有消息，并且当前时候大于等于消息中的执行时间，那么就直接返回这个消息给Looper.loop消息处理，否则的话就要等待到消息的执行时间： 1nextPollTimeoutMillis = (int) Math.min(when - now, Integer.MAX_VALUE); 如果消息队列中没有消息，那就进入到无穷等待状态直到有新消息： 1nextPollTimeoutMillis = -1; -1表示下次调用nativePollOnce时，如果消息中没有消息就进入无限等待状态中去。这里计算出来的等待时间是在下次调用nativePollOnce的时候使用。 这里说的等待，是空闲等待，而不是忙等待，因此，在进入空闲等待状态前，如果应用程序注册了IdleHandler接口来处理一些事情，那么就会先执行这里IdleHandler，然后再进入等待状态。 12345678910111213141516 // If first time idle, then get the number of idlers to run.// Idle handles only run if the queue is empty or if the first message// in the queue (possibly a barrier) is due to be handled in the future.if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size();&#125;if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue;&#125;if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];&#125;mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); 如果没有IdleHandler即pendingIdleHandlerCount等于0，那么下面的逻辑就不执行了，通过continue语句直接进入下一次循环，否则就把注册的mPendingIdleHandlers中的IdleHandler取出来，放到mPendingIdleHandler数组中，并循环执行这些注册了的IdelHandler： 12345678910111213141516171819// Run the idle handlers.// We only ever reach this code block during the first iteration.for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(\"MessageQueue\", \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125;&#125; 执行完这些IdleHandler之后，下次再次调用nativePollOnce函数的时候，就不设置超时时间了，因为很有可能在执行IdleHandler的时候，已经有新的消息加入到消息队列中去了，因此，要重置nextPollTimeoutMillis的值： 123// While calling an idle handler, a new message could have been delivered// so go back and look again for a pending message without waiting.nextPollTimeoutMillis = 0; 分析完MessageQueue的next方法之后，我们来稍微深入的分析下JNI方法nativePollOnce了，看看它是如何进入等待状态的，这个函数在frameworks/base/core/jni/android_os_MessageQueue.cpp文件中： 12345678910111213static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jint ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, timeoutMillis);&#125;static JNINativeMethod gMessageQueueMethods[] = &#123; /* name, signature, funcPtr */ &#123; \"nativeInit\", \"()V\", (void*)android_os_MessageQueue_nativeInit &#125;, &#123; \"nativeDestroy\", \"()V\", (void*)android_os_MessageQueue_nativeDestroy &#125;, &#123; \"nativePollOnce\", \"(II)V\", (void*)android_os_MessageQueue_nativePollOnce &#125;, &#123; \"nativeWake\", \"(I)V\", (void*)android_os_MessageQueue_nativeWake &#125;&#125;; 这个函数首先是通过传进来的参数ptr取回在Java层创建的MessageQueue对象时在JNI层创建的NativeMessageQueue对象： 123456789public final class MessageQueue &#123; private long mPtr; // used by native code .... MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit(); &#125; .....&#125; 12345678910static void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return; &#125; nativeMessageQueue-&gt;incStrong(env); android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);&#125; 取到NativeMessageQueue对象，然后调用它的pollOnce函数 12345678910void NativeMessageQueue::pollOnce(JNIEnv* env, int timeoutMillis) &#123; mInCallback = true; mLooper-&gt;pollOnce(timeoutMillis); mInCallback = false; if (mExceptionObj) &#123; env-&gt;Throw(mExceptionObj); env-&gt;DeleteLocalRef(mExceptionObj); mExceptionObj = NULL; &#125;&#125; 这里把操作转给mLooper对象的pollOnce函数处理，这里的mLooer对象是C++层的对象，它也是在JNI层创建NativeMessageQueue对象时创建的： 1234567NativeMessageQueue::NativeMessageQueue() : mInCallback(false), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; mLooper = new Looper(false); Looper::setForThread(mLooper); &#125;&#125; 它的pollOnce函数在Looper.cpp(JellyBean、Lollipop)中: 123456789101112int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; for (;;) &#123; .... if (result != 0) &#123; ..... return result; &#125; result = pollInner(timeoutMillis); &#125;&#125; 我们只看核心部分，这里主要是继续调用pollInner函数来进一步操作，如果pollInner返回不等于0，这个函数就可以返回了。 pollInner的定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687int Looper::pollInner(int timeoutMillis) &#123; ..... // Poll. int result = ALOOPER_POLL_WAKE; mResponses.clear(); mResponseIndex = 0; struct epoll_event eventItems[EPOLL_MAX_EVENTS]; int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); // Acquire lock. mLock.lock(); // Check for poll error. if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; ALOGW(\"Poll failed with an unexpected error, errno=%d\", errno); result = ALOOPER_POLL_ERROR; goto Done; &#125; // Check for poll timeout. if (eventCount == 0) &#123; ..... result = ALOOPER_POLL_TIMEOUT; goto Done; &#125; ..... for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeReadPipeFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents); &#125; &#125; else &#123; ..... &#125; &#125;Done: ; // Invoke pending message callbacks. mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) &#123; // Remove the envelope from the list. // We keep a strong reference to the handler until the call to handleMessage // finishes. Then we drop it so that the handler can be deleted *before* // we reacquire our lock. &#123; // obtain handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); .... handler-&gt;handleMessage(message); &#125; // release handler mLock.lock(); mSendingMessage = false; result = ALOOPER_POLL_CALLBACK; &#125; else &#123; // The last message left at the head of the queue determines the next wakeup time. mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; // Release lock. mLock.unlock(); // Invoke all response callbacks. ...... return result;&#125; 这个函数比较长并且其中用到了goto，我们仍然只关注核心代码，我们看到函数开头首先是调用epoll_wait函数来看看epoll专用文件描述符mEpollFd所监控的文件描述符是否有IO事件发生，它设置监控的超时时间为pollOnce函数传递过来的timeoutMillis： 1int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-03-07T09:45:43.459Z","updated":"2017-03-07T09:45:43.466Z","comments":true,"path":"2017/03/07/hello-world/","link":"","permalink":"http://yoursite.com/2017/03/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]}]}