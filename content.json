{"meta":{"title":"JasonZhang's Blog","subtitle":"码农Jason的心得","description":"Android开发、架构师，学习新知识，了解新动态！","author":"Jason Zhang","url":"http://jasonzhang1986.github.io"},"pages":[{"title":"","date":"2017-04-27T07:41:55.826Z","updated":"2017-04-27T07:41:55.826Z","comments":true,"path":"404.html","permalink":"http://jasonzhang1986.github.io/404.html","excerpt":"","text":"","raw":null,"content":null},{"title":"分类","date":"2017-04-27T07:36:27.000Z","updated":"2017-04-28T02:41:17.657Z","comments":false,"path":"categories/index.html","permalink":"http://jasonzhang1986.github.io/categories/index.html","excerpt":"","text":"","raw":null,"content":null},{"title":"标签","date":"2017-03-10T10:18:27.000Z","updated":"2017-04-28T02:46:33.916Z","comments":false,"path":"tags/index.html","permalink":"http://jasonzhang1986.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"Android面试题集","slug":"interview-questions","date":"2017-08-14T02:43:37.066Z","updated":"2017-08-14T02:51:06.501Z","comments":true,"path":"2017/08/14/interview-questions/","link":"","permalink":"http://jasonzhang1986.github.io/2017/08/14/interview-questions/","excerpt":"","text":"Android相关 Activity正常和异常情况下的生命周期 Link Activity的四种启动模式 app如何保证后台服务不被杀死 Activity与Fragment生命周期有何联系 Activity与Fragment之间如何进行通信？ IntentService比Service好在哪 如何优雅的展示Bitmap大图 Retrofit使用的注解是哪种注解？以及，注解的底层实现是怎样的 Thread和HandlerThread区别 关于&lt; include &gt;&lt; merge &gt;&lt; stub &gt;三者的使用场景 对Android消息机制的理解 如何优化一个ListView? 哪些情况会导致OOM？ 造成ANR 的原因？ 如何监测内存泄露？有哪些工具？ 用leak工具监测内存泄露的原理是什么？ RxJava中map和flatmap操作符的区别及底层实现 对消息机制中Looper的理解 界面卡顿的原因有哪些？ RecyclerView与ListView缓存机制的不同 android什么情况下会发生内存泄露 Java相关 Java是值传递还是引用传递 final和static关键字的区别 static修饰的方法可以被子类重写吗？为什么？ HashMap HashSet HashTable的区别？ 如何让HashMap可以线程安全？ 序列化是什么?如何实现它? 垃圾收集器是什么?它是如何工作的 深拷贝和浅拷贝的区别 clone()的默认实现是深拷贝还是浅拷贝?如何让clone()实现深拷贝？ 动态代理和静态代理 JVM的内存分布及垃圾回收机制 Java有哪几种创建新线程的方法及区别 ThreadLocal的理解 Java多线程之间如何通信 线程池的实现机制 Integer类对int的优化 单例模式有哪些实现方式 通过静态内部类实现单例模式有哪些优点 synchronized volatile关键字有什么区别？以及还有哪些同样功能的关键字 操作系统进程间通信有哪些方法 谈谈对Socket的理解 不同架构的机器有何不同（如x86等） TCP/UDP比较 什么时候会发生死锁 操作系统层面上，线程可以加哪些锁 栈在系统中的方向是怎样的？为什么？ Java 中的类型转换 修饰符transient和volatile的作用是什么？ 算法题 求二叉树第n层节点数 两个有序链表合并 求无序数组中的中位数 二叉树深度算法","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://jasonzhang1986.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jasonzhang1986.github.io/tags/Android/"}]},{"title":"Android通信机制分析-Binder(1)","slug":"binder","date":"2017-04-29T01:31:13.000Z","updated":"2017-05-04T02:27:50.325Z","comments":true,"path":"2017/04/29/binder/","link":"","permalink":"http://jasonzhang1986.github.io/2017/04/29/binder/","excerpt":"","text":"概述Android四大组件分别是 Activity、Service、BroadcastReceiver、ContentProvider，我们平时开发的 App 都是由四大组件中的一个或者多个组合而成；这四大组件所涉及的多进程间通信底层实现都是基于 Binder 的 IPC 机制。 我们平时开发过程中用到很多跨进程的通信，比如： App 中的 ActivityA 调用系统的 ActivityB App 中的 ActivityA 调用另一个 App 的 Service Binder 作为 Android 系统提供的一种的 IPC 机制，整个 Android 系统架构中大量采用了 Binder 机制的 IPC 方案。 IPC说到 IPC，我们来稍微看一下 IPC 机制的原理：进程间通信（IPC, Inter-Process Communication） 指至少两个进程或线程减传送数据或者信号的技术或方法。每个进程都有自己的一部分独立的系统资源，彼此之间是隔离的。为了能使不同的进程相互访问资源并进行协调工作，才有了进程间通信。IPC 的方法有多种，包括文件、Socket、管道、信号量、共享内存 等，我们今天主要来说说 Android 中的 Binde r。 Binder概念每个 Android 在各自独立的 Dalvik 虚拟机中运行，每个进程拥有独立的地址空间和资源，对应的地址空间有一部分是用户空间，另一部分是内核空间。对于用户空间，不同进程之间彼此是不能共享的，而内核空间则是可以共享的，Client 进程同 Server 进程通信，就是利用进程间可共享的内核空间(内核驱动)来完成底层通信工作的。 IPC 机制 Android 中 Binder 通信采用的是 C/S 架构，Binder 框架包括 Client、Server、ServiceManager 以及 Binder 驱动，其中 ServiceManager 用来管理系统中各种服务。其中 Server，Client，ServiceManager 运行于用户空间，Binder 驱动运行于内核空间。这四个角色的关系和互联网类似：Server 是服务器，Client 是客户终端，ServiceManager 是域名服务器（DNS），Binder 驱动是路由器。如图： Binder Binder使用实例Binder 是 Android 中一个类，它实现 IBinder 接口，从 IPC 方面来看 Binder 是一种跨进程通信的方式，从 Framework 方面来看 Binder 是 ServiceManager 连接各种 Manager (WindowManager, ActivityManager 等等)和相应的 ManagerService (WindowManagerService, ActivityManagerService 等等)的桥梁； AMS 架构 对客户端应用来说，Binder 是客户端和服务端通信的媒介，当bindService的时候，服务端会返回一个包含服务端业务调用的 Binder 对象，通过这个 Binder 对象客户端可以获取服务端提供的服务、数据等。123456789101112131415161718192021222324252627public class LocalService extends Service &#123; // Binder given to clients private final IBinder mBinder = new LocalBinder(); // Random number generator private final Random mGenerator = new Random(); /** * Class used for the client Binder. Because we know this service always * runs in the same process as its clients, we don't need to deal with IPC. */ public class LocalBinder extends Binder &#123; LocalService getService() &#123; // Return this instance of LocalService so clients can call public methods return LocalService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; //通过 onBind 返回一个服务端的 Binder 对象 &#125; /** method for clients */ public int getRandomNumber() &#123; return mGenerator.nextInt(100); &#125;&#125; 上面这段代码是 Service 的一种实现方式，这里的 Binder 不涉及跨进程通信，所以比较简单，跨进程的 Binder 使用在 Android 中主要是 Messager 和 AIDL，Messager 的底层实现也是 AIDL，所以我们先来聊聊 AIDL。 AIDL新建一个 AIDL 的文件 新建 AIDL File 新建后会自动生成 aidl 的目录，并将新建的 AIDL 文件放到该目录下 生成的aidl目录 Book.aidl 文件内容是自动生成的，我们可以根据自己的需求进行修改, 自动生成的代码标记了 import 语句的地方和可以用做 AIDL 参数和返回值的一些基本类型12345678910111213// Book.aidlpackage me.jifengzhang.aidldemo;// Declare any non-default types here with import statementsinterface Book &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 这个demo主要是提供 Book 的两个操作，我们新建的文件包括 Book.java 、 IBook.aidl 、 IBookManager.aidl，其中 Book 对象需要跨进程通过Binder传输，所以需要实现 Parcelable 接口。 Book.java123456789101112131415161718192021222324252627282930313233343536373839import android.os.Parcelable;public class Book implements Parcelable&#123; public int bookId; public String bookName; public Book(int bookId, String bookName) &#123; this.bookId = bookId; this.bookName = bookName; &#125; protected Book(Parcel in) &#123; bookId = in.readInt(); bookName = in.readString(); &#125; public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel in) &#123; return new Book(in); &#125; @Override public Book[] newArray(int size) &#123; return new Book[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(bookId); dest.writeString(bookName); &#125;&#125; Book.aidl123package me.jifengzhang.aidldemo;parcelable Book; IBookManager.aidl12345678package me.jifengzhang.aidldemo;import me.jifengzhang.aidldemo.Book;interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book);&#125; 编译后，会自动生成 IBookManager.aidl 对应的 java 文件(app/build/generated/source/aidl/debug/me/jifengzhang/aidldemo/IBookManager.java)，格式调整后如下：123456789101112131415package me.jifengzhang.aidldemo;public interface IBookManager extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements me.jifengzhang.aidldemo.IBookManager &#123; ... &#125; public java.util.List&lt;me.jifengzhang.aidldemo.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(me.jifengzhang.aidldemo.Book book) throws android.os.RemoteException; 这个类结构其实很简单，它继承了 IInterface 接口（所有可以在 Binder 中传输的接口都需要继承 IInterface 接口）同时它自己也是一个接口类，可以看到其实它的内部结构就是声明了两个方法 getBookList 和 addBook (显然这两个方法是 IBookManager.aidl 中声明的)，同时还有一个内部类 Stub，这个类就是一个 Binder 类（很明显 Stub 继承 Binder）。但我们应该认识到 IBookManager.java 的核心实现是 Stub 以及 Stub 的内部代理类 Proxy。 下面详细介绍下 Stub 以及内部代理类 Proxy 中各个方法的含义： DESCRIPTOR Binder 的唯一标识符，一般使用当前 Binder 的类名表示， 比如上述例子中的 “me.jifengzhang.aidldemo.IBookManager” asInterface 转换服务端传递过来的 IBinder 对象为客户端需要的 AIDL 接口类型的对象，这个转换过程是区分进程的，如果客户端和服务端是同一个进程，那么该方法返回的就是服务端的 Stub 对象本身，当然如果不是同一个进程则返回的是封装后的 Stub.Proxy 对象。1234567891011public static me.jifengzhang.aidldemo.IBookManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof me.jifengzhang.aidldemo.IBookManager))) &#123; //同一个进程 return ((me.jifengzhang.aidldemo.IBookManager) iin); &#125; //不同进程 return new me.jifengzhang.aidldemo.IBookManager.Stub.Proxy(obj);&#125; asBinder 该方法用于返回当前 Binder 对象 onTransact 该方法运行在服务端的 Binder 线程池中， 当客户端发起跨进程请求时，远程请求会通过系统底层封装后交给该方法处理。服务端通过 code 来确定客户端请求的方法是什么，从 data：Parcel 中取出方法所需要的参数，然后执行目标方法，最后将方法执行的结果（返回值）存到 replay: Parcel 中。 Proxy#getBookList 该方法运行在客户端，当客户端调用该方法时，首先创建该方法所需要的输入 Parcel 对象 _data, 输出 Parcel 对象 _reply 以及返回值 List，然后将参数信息写入 _data 中，接着调用 transact 方法发起远程调用 RPC ，此时客户端当前线程挂起，服务端的 onTransact 方法会被调用执行，直到 RPC 过程返回后，客户端当前线程继续执行，并从 _reply 中取出 RPC 过程的返回结果。最后将 _reply 转换成 List 返回。 ** Proxy#addBook 执行过程和 getBookList 一样。 通过简单的分析描述，其实 AIDL 的实现其实很简单，方法调用的流程大概如下： AIDL 流程 服务端（Service）实现上面简单说明了 AIDL 中接口的定义，这里我们来看看服务端也就是作为服务提供者的 Service 的实现，我们可以想到的是 Service 肯定是要实现 IBookManager 定义的两个接口，剩余的应该有 Service 的基本实现。那我们来看代码：12345678910111213141516171819202122232425262728public class BookManagerService extends Service &#123; private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;&gt;(); private Binder mBinder = new IBookManager.Stub() &#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; @Override public void addBook(Book book) throws RemoteException &#123; mBookList.add(book); &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mBookList.add(new Book(1, \"Android\")); mBookList.add(new Book(2, \"IOS\")); &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 果然，代码和我们想的是一样的，这里通过 new 一个 Stub (IBookManager 的内部类，继承自 Binder)来实现 getBookList 和 addBook 两个接口方法。 客户端的实现客户端也就是访问端的实现也比较简单，首先是绑定服务(BinderService)，绑定成功后将服务端返回的 Binder 对象转换为 AIDL 接口，然后就可以使用这个接口来调用 Server 端的远程方法。12345678910111213141516171819202122232425262728293031323334@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //绑定服务 Intent intent = new Intent(this, BookManagerService.class); bindService(intent, mServiceConnect, Context.BIND_AUTO_CREATE);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); //解绑 unbindService(mServiceConnect);&#125;private ServiceConnection mServiceConnect = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //将服务端传递过来的Binder对象转换为AIDL接口 IBookManager manager = IBookManager.Stub.asInterface(service); try &#123; List&lt;Book&gt; list = manager.getBookList(); Log.i(\"MainActivity\", \"queue book list : \" + list.toString()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125;&#125;; 运行结果我们在 Manifest 中给 BookManagerService 设置 process 属性，这样 BookManagerService 和 MainActivity 就是不同的进程。 1&lt;service android:name=&quot;.BookManagerService&quot; android:process=&quot;:remote&quot;/&gt; 运行结果：105-04 10:10:28.622 17622-17622/me.jifengzhang.aidldemo I/MainActivity: queue book list : [[1:Android], [2:IOS]] 参考Gityuan Android 开发艺术探索","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://jasonzhang1986.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jasonzhang1986.github.io/tags/Android/"},{"name":"Binder","slug":"Binder","permalink":"http://jasonzhang1986.github.io/tags/Binder/"}]},{"title":"Hexo接入网易云评论","slug":"hexo-comment-neteast","date":"2017-04-28T02:02:14.000Z","updated":"2017-04-28T02:54:31.520Z","comments":true,"path":"2017/04/28/hexo-comment-neteast/","link":"","permalink":"http://jasonzhang1986.github.io/2017/04/28/hexo-comment-neteast/","excerpt":"","text":"搞了GitPage之后不久看到多说评论6月份要关闭的消息，一直在琢磨换哪家，大家都有不同的观点，我还是觉得网易的云跟帖值得拥有，毕竟是大厂并且是易友好多年。 不多说，说干就干。我使用的是Hexo的插件indigo。 注册网易云跟帖填写站点的基本信息 mark 填写站长信息 mark 获取代码 mark 代码留作稍后使用 插件配置在themes/indigo/layout/_partial/plugins/下创建neteast.ejs文件，仿照原有的duoshuo.ejs将刚刚复制的云跟帖代码加入到如下代码中间12345&lt;% if (theme.netease)&#123; %&gt; ......&lt;% &#125; %&gt; 最后的neteast.ejs内容如下（其中的productKey的Tie.loader内容请替换为自己申请的）：1234567891011121314&lt;% if (theme.netease)&#123; %&gt; &lt;div id=\"cloud-tie-wrapper\" class=\"cloud-tie-wrapper\"&gt;&lt;/div&gt; &lt;script src=\"https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js\"&gt;&lt;/script&gt; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: \"\", productKey: \"**********************\", target: \"cloud-tie-wrapper\" &#125;; var yunManualLoad = true; Tie.loader(\"*********************\", true); &lt;/script&gt;&lt;% &#125; %&gt; 在comment的配置文件themes/indigo/layout/_partial/post/comment.ejs中添加刚刚加入的评论配置文件1&lt;%- partial('../plugins/netease') %&gt; 最后，在主题的config文件(themes/indigo/_config.yml)中关闭duoshuo，打开neteast123duoshuo: falsenetease: true 当然，不能忘记了编译下，12hexo cleanhexo g -d 注意：部署到web端才能看到网易云评论，在localhost测试的时候一直不行，以为以为配置错误呢，尴尬… 参考多说要关闭了，修改为使用搜狐畅言评论插件 替换多说到网易云跟帖","raw":null,"content":null,"categories":[{"name":"笔记","slug":"笔记","permalink":"http://jasonzhang1986.github.io/categories/笔记/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://jasonzhang1986.github.io/tags/Hexo/"},{"name":"网易云评论","slug":"网易云评论","permalink":"http://jasonzhang1986.github.io/tags/网易云评论/"}]},{"title":"AndroidStudio上传aar到Nexus","slug":"NexusUpload","date":"2017-04-21T07:51:16.836Z","updated":"2017-05-02T10:28:17.717Z","comments":true,"path":"2017/04/21/NexusUpload/","link":"","permalink":"http://jasonzhang1986.github.io/2017/04/21/NexusUpload/","excerpt":"","text":"最近因为公司项目需要，多个组开发的项目依赖于一些公共的Library，正好公司也有Nexus仓库，于是就学习下如何如何将自己的Library上传到Nexus仓库供大家使用。 1. 发布Library到私服先展示下我建立的Project的目录结果 mark app目录大家最熟悉了，是AS默认的主module的名字，utils目录就是我新建立的library module。 接下来我们来配置maven的上传 配置pom参数项目根目录下的gradle.properties中添加如下pom参数123456POM_NAME=utilsPOM_VERSION=1.0.1POM_ARTIFACTID=utilsPOM_GROUPID=com.leplay.androidPOM_PACKAGING=aarPOM_DESCRIPTION=utils for Android 配置Nexus参数因为Nexus相关参数是固定的，包含仓库地址、用户名和密码，我们把这些参数写到gradle的Global配置中，目录是C:\\Users\\(用户名)\\.gradle\\gradle.properties123NEXUS_USERNAME=usernameNEXUS_PASSWORD=passwordNEXUS_REPOSITORY_URL=http://xxx/nexus/content/repositories/xxx/ 引入upload脚本在library的build.gradle文件末尾加上如下引用：1apply from: 'http://jifengzhang.me/nexus_upload.gradle' 这个nexus_upload.gradle脚本是参考大神的脚本修改，包含生成java-source和java-doc，具体实现细节可以进入看脚本代码。 uploadArchives编译并上传library，双击右侧gradle task中的uploadArchives mark 等待一会出现Success字样，证明已经上传成功 mark 最后我们去Nexus上查看下，确实上传成功了 mark 2. 使用Nexus私服上的Library首先，要在项目的build.gradle里面声明私服的地址 mark 然后就是我们最熟悉的在module的build.gradle文件中添加依赖1compile 'com.leplay.android:utils:1.0.1'","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://jasonzhang1986.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jasonzhang1986.github.io/tags/Android/"},{"name":"Nexus","slug":"Nexus","permalink":"http://jasonzhang1986.github.io/tags/Nexus/"}]},{"title":"Atom遇到的坑","slug":"Atom插件下载失败","date":"2017-04-20T07:51:25.311Z","updated":"2017-04-27T07:56:28.477Z","comments":true,"path":"2017/04/20/Atom插件下载失败/","link":"","permalink":"http://jasonzhang1986.github.io/2017/04/20/Atom插件下载失败/","excerpt":"","text":"win10下atom安装插件失败，提示如下图： mark 然后我尝试用apm install的方式，结果： mark Google搜索发现不少人遇到同样的问题，在atom-china上发现一个方法可用，这里记录下： 我也碰到过这个问题，后来解决了，似乎是因为墙的问题。如果你把 Show output，点开，可以看到跟下面类似的信息：123456gyp info it worked if it ends with okgyp info using node-gyp@2.0.2gyp info using node@0.10.40 | win32 | ia32gyp http GET https://atom.io/download/atom-shell/v0.30.7/node-v0.30.7.tar.gzgyp WARN install got an error, rolling back installgyp 我的解决方案是设置代理： 打开 C:\\Users\\XXX.atom\\ 目录下的.apmrc配置文件（没有就新建一个）,然后添加代理信息：123strict-ssl=falsehttps-proxy=http://127.0.0.1:1080/http-proxy =http://127.0.0.1:1080/ 这里的 http://127.0.0.1:1080，是我自己的 Shadowsocks 代理，你需要设置成自己的可用代理。然后再执行 apm install –check，应该可以测试成功，祝好运~~ mark","raw":null,"content":null,"categories":[{"name":"工具","slug":"工具","permalink":"http://jasonzhang1986.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://jasonzhang1986.github.io/tags/工具/"},{"name":"Atom","slug":"Atom","permalink":"http://jasonzhang1986.github.io/tags/Atom/"}]},{"title":"you-get遇到的坑","slug":"you-get","date":"2017-04-18T09:37:26.264Z","updated":"2017-04-27T07:56:45.075Z","comments":true,"path":"2017/04/18/you-get/","link":"","permalink":"http://jasonzhang1986.github.io/2017/04/18/you-get/","excerpt":"","text":"you-get好用的下载器 https://github.com/soimort/you-get 我使用choco install的，官方提供了多种安装方式总有一款适合你 使用Shadowsocks代理，在下载YouTube的时候出现SSL错误，证书认证错误，查看帮助(you-get –help)看到有sock-proxy选项 于是使用如下命令（–debug是显示debug信息）： 1you-get -s 127.0.0.1:1080 --debug -i 'https://www.youtube.com/watch?v=jNQXAC9IVRw' 结果如下图 可以看到是展示了多种分辨率，那我们就可以选择需要的分辨率下载了 1you-get -s 127.0.0.1:1080 --debug --itag=242 'https://www.youtube.com/watch?v=jNQXAC9IVRw' 结果下载失败： 曾遇到过需要安装PySocks这个库，在使用pip install的时候出现 1pip install fails with “connection error: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:598)” 通过Google通过添加trust参数来解决 1pip3 install --index-url=http://pypi.python.org/simple/ --trusted-host pypi.python.org pythonPackage 下载失败或者SSL问题仍然出现，查看issue发现不止我一人遇到这样的问题 https://github.com/soimort/you-get/issues/1684 发现也没有好的解决方案，决定换个vpn试试，改换Greenvpn之后再次尝试 终于下载成功！！！","raw":null,"content":null,"categories":[{"name":"工具","slug":"工具","permalink":"http://jasonzhang1986.github.io/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://jasonzhang1986.github.io/tags/工具/"}]},{"title":"Android的消息机制分析","slug":"Handler","date":"2017-03-10T09:37:59.736Z","updated":"2017-08-14T02:47:50.005Z","comments":true,"path":"2017/03/10/Handler/","link":"","permalink":"http://jasonzhang1986.github.io/2017/03/10/Handler/","excerpt":"","text":"Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。1. 概述今天我们主要来聊一聊进程内部的消息机制Handler。 从技术实现来说消息机制并不复杂，不只是Android平台,各种平台的消息机制原理基本上都是比较相似的，其中用到的主要概念有： 消息发送者 消息队列 消息循环处理 简单示意图如下： image 图中表达的意思是，消息发送者通过某种方式将消息发送到消息队列中，同时还有一个消息处理循环，不断从消息队列里取消息，并进行处理。 Android的消息机制主要是指Handler的运行机制，Hander的运行需要相关的MessageQueue和Looper的支撑。图中右侧的部分可以理解为Android中的Looper类，这个类的内部有对应的消息队列(MessageQueue mQueue)和loop方法(取消息的循环) 从我们开发者的角度来说，Handler是Android消息机制的最上层接口，这使得我们在开发过程中绝大多数情况下只需要和Handler打交道就可以，Handler的使用方法也很简单，我们常常在子线程中需要更新UI时使用，常见代码如下： 123456789101112131415161718192021222324private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case xxx: ... updateUI(); break; &#125; &#125; &#125;; .... private void threadMethod() &#123; new Thread()&#123; @Override public void run() &#123; super.run(); ... handler.sendMessage(msg); ... &#125; &#125;.start(); &#125; 在子线程中创建并使用Handler：12345678910111213141516//在子线程中使用Handler class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125; &#125; 从上面两个例子，我们可以看到通过handler的sendMessage方法来发送消息，通过Looper.loop方法来进行消息循环；至于消息处理是隐藏在Loop和MessageQueue中，我们接下来会一点点来深入分析。 说到Handler我们先来看下它的构造方法，开发过程中经常用到的构造方法是Handler()和Handler(Looper looper); 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Handler&#123; final MessageQueue mQueue; final Looper mLooper; final Callback mCallback; final boolean mAsynchronous; ..... public Handler() &#123; this(null, false); &#125; public Handler(Looper looper) &#123; this(looper, null, false); &#125; public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; &#125; ...... &#125; 通过如上代码我们可以看到构造方法目的都是为了给mLooper、mQueue、mCallback和mAsyncronous赋值，callback和async这两个我们用的较少，我们此次重点关注mLooper和mQueue。 1Handler handler = new Handler(Looper.getMainLooper()); 如上是我们常用的指定了Looper的构造方法，内部实现很简单，直接就赋值： 123456789101112131415/** * Use the provided &#123;@link Looper&#125; instead of the default one. * * @param looper The looper, must not be null. */ public Handler(Looper looper) &#123; this(looper, null, false); &#125;public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; &#125; 另一个更常用的构造方法是如下这种： 1234567891011121314151617181920212223242526272829Handler handler = new Handler();public class Handler &#123; .... /** * Default constructor associates this handler with the &#123;@link Looper&#125; for the * current thread. * * If this thread does not have a looper, this handler won't be able to receive messages * so an exception is thrown. */ public Handler() &#123; this(null, false); &#125; public Handler(Callback callback, boolean async) &#123; ..... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; ....&#125; 因为默认构造方法没有入参，那么mLooper通过Looper自身的myLooper方法来获取，判断mLooper是否为null，如果非空则给mQueue、callback等赋值，如果等于null则说明Handler是在线程中创建并且创建前没有调用Looper的prepare()方法；那我们猜想肯定是在Looper.prepare()方法中初始化了Looper对象。 这里有两个疑问 在Activity(UI线程)中new Handler()的时候也没有去调用Looper.prepare()，为什么没有抛异常？ Looper.prepare()是如何初始化Looper对象并在通过myLooper方法向外部提供引用的？ 我们先来看第二个问题，还是老方法直接看源码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Looper &#123; // sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); final MessageQueue mQueue; final Thread mThread; volatile boolean mRun; ..... /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */ public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; .... private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mRun = true; mThread = Thread.currentThread(); &#125; /** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */ public static Looper myLooper() &#123; return sThreadLocal.get(); &#125;&#125; 代码实现很简单，就是new一个Looper对象set给sThreadLocal，然后获取是通过sThreadLocal的get方法。这样我们明白了为什么在thread中new Handler前要调用Looper.parepare()。 接下来我们回头看问题1，为什么在UI线程中可以直接new Handler()来使用呢？UI线程直接初始化Handler没有抛异常说明sThreadLocal.get()返回值不是空，也就是已经set过Looper对象，那是哪里设置的呢？ 了解应用启动流程的应该知道，应用的main方法在ActivityThread中，在main方法中完成了一些初始化工作，我们来看main方法中做了什么12345678910111213141516public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if(sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ... Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 这里我们看到了熟悉的Looper.prepare和Looper.loop，不过这里调用的是Looper的另一个方法prepareMainLooper，跟进去看 1234567891011121314151617181920212223public static void prepareMainLooper() &#123; prepare(false); Class var0 = Looper.class; synchronized(Looper.class) &#123; if(sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; else &#123; sMainLooper = myLooper(); &#125; &#125;&#125;public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if(sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; else &#123; sThreadLocal.set(new Looper(quitAllowed)); &#125;&#125; 可以看到prepareMainLooper()和prepare()调用的是Looper的同一个方法prepard(boolean quitAllowed)，UI线程的Looper是不允许退出的(如果允许退出，调用了quit岂不UI就无法刷新啦)，其他线程的Looper是允许退出的。 所以，UI线程并非特殊，而是在更早的时候系统已经做好了Looper的初始化操作。既然已经发现了系统初始化Looper的地方，那UI线程是不是也有自己的Handler来处理消息呢？答案显示是有的。 prepare方法调用后，创建Handler,这里是new ActivityThread对象，ActivityThread有实例变量mH就是Handler的对象12345678910111213141516171819202122main() &#123; ... ActivityThread thread = new ActivityThread(); if(sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ...&#125;final ActivityThread.H mH = new ActivityThread.H(null);final Handler getHandler() &#123; return this.mH;&#125;...private class H extends Handler &#123; ...&#125; 2. 消息循环到这里Looper和Handler都准备好，还有个必须要做的就是开启消息循环Looper.loop()。 12345678910111213141516171819202122232425262728/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; ... for (;;) &#123; //永久循环 Message msg = queue.next(); // might block if (msg == null) &#123; //死循环退出条件 // No message indicates that the message queue is quitting. return; &#125; ... msg.target.dispatchMessage(msg);//这里的target是Handler ... &#125; &#125; 说到消息的循环，就不得不提MessageQueue中next方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; ...... nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. // 如果从队列里拿到的msg是个“同步分割栏”，那么就寻找其后第一个“异步消息” do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; ...... // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 调用这个方法的时候，有可能让线程进入等待状态。什么情况下线程会进入等待状态呢？有如下两种情况 当消息队列中没有消息是，它会使线程进入等待状态 消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态 消息队列中的消息是按照时间先后来排序的，后面我们在分析消息发送的时候会看到。 大家可能注意到如下一条native的语句，它是查看当前消息队列中有没有消息： 1nativePollOnce(mPtr, nextPollTimeoutMillis); 这是一个JNI方法，我们等一下再分析，这里传入的参数mPtr就是指向前面我们在JNI层创建的NativeMessageQueue对象了，而参数nextPollTimeoutMillis则表示如果当前消息队列中没有消息，它要等待的时候，for循环开始时，传入的值为0，表示不等待。 当前nativePoolOnce返回后，就去看看消息队列中有没有消息： 1234567891011121314151617181920if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg); return msg; &#125;&#125; else &#123; // No more messages. nextPollTimeoutMillis = -1;&#125; 如果消息队列中有消息，并且当前时候大于等于消息中的执行时间，那么就直接返回这个消息给Looper.loop消息处理，否则的话就要等待到消息的执行时间： 1nextPollTimeoutMillis = (int) Math.min(when - now, Integer.MAX_VALUE); 如果消息队列中没有消息，那就进入到无穷等待状态直到有新消息： 1nextPollTimeoutMillis = -1; -1表示下次调用nativePollOnce时，如果消息中没有消息就进入无限等待状态中去。这里计算出来的等待时间是在下次调用nativePollOnce的时候使用。 这里说的等待，是空闲等待，而不是忙等待，因此，在进入空闲等待状态前，如果应用程序注册了IdleHandler接口来处理一些事情，那么就会先执行这里IdleHandler，然后再进入等待状态。 12345678910111213141516 // If first time idle, then get the number of idlers to run.// Idle handles only run if the queue is empty or if the first message// in the queue (possibly a barrier) is due to be handled in the future.if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size();&#125;if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue;&#125;if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];&#125;mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); 如果没有IdleHandler即pendingIdleHandlerCount等于0，那么下面的逻辑就不执行了，通过continue语句直接进入下一次循环，否则就把注册的mPendingIdleHandlers中的IdleHandler取出来，放到mPendingIdleHandler数组中，并循环执行这些注册了的IdelHandler： 12345678910111213141516171819// Run the idle handlers.// We only ever reach this code block during the first iteration.for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(\"MessageQueue\", \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125;&#125; 执行完这些IdleHandler之后，下次再次调用nativePollOnce函数的时候，就不设置超时时间了，因为很有可能在执行IdleHandler的时候，已经有新的消息加入到消息队列中去了，因此，要重置nextPollTimeoutMillis的值： 123// While calling an idle handler, a new message could have been delivered// so go back and look again for a pending message without waiting.nextPollTimeoutMillis = 0; 分析完MessageQueue的next方法之后，我们来稍微深入的分析下JNI方法nativePollOnce了，看看它是如何进入等待状态的，这个函数在frameworks/base/core/jni/android_os_MessageQueue.cpp文件中： 12345678910111213static void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jint ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, timeoutMillis);&#125;static JNINativeMethod gMessageQueueMethods[] = &#123; /* name, signature, funcPtr */ &#123; \"nativeInit\", \"()V\", (void*)android_os_MessageQueue_nativeInit &#125;, &#123; \"nativeDestroy\", \"()V\", (void*)android_os_MessageQueue_nativeDestroy &#125;, &#123; \"nativePollOnce\", \"(II)V\", (void*)android_os_MessageQueue_nativePollOnce &#125;, &#123; \"nativeWake\", \"(I)V\", (void*)android_os_MessageQueue_nativeWake &#125;&#125;; 这个函数首先是通过传进来的参数ptr取回在Java层创建的MessageQueue对象时在JNI层创建的NativeMessageQueue对象： 123456789public final class MessageQueue &#123; private long mPtr; // used by native code .... MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit(); &#125; .....&#125; 12345678910static void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return; &#125; nativeMessageQueue-&gt;incStrong(env); android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);&#125; 取到NativeMessageQueue对象，然后调用它的pollOnce函数 12345678910void NativeMessageQueue::pollOnce(JNIEnv* env, int timeoutMillis) &#123; mInCallback = true; mLooper-&gt;pollOnce(timeoutMillis); mInCallback = false; if (mExceptionObj) &#123; env-&gt;Throw(mExceptionObj); env-&gt;DeleteLocalRef(mExceptionObj); mExceptionObj = NULL; &#125;&#125; 这里把操作转给mLooper对象的pollOnce函数处理，这里的mLooer对象是C++层的对象，它也是在JNI层创建NativeMessageQueue对象时创建的： 1234567NativeMessageQueue::NativeMessageQueue() : mInCallback(false), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; mLooper = new Looper(false); Looper::setForThread(mLooper); &#125;&#125; 它的pollOnce函数在Looper.cpp(JellyBean、Lollipop)中: 123456789101112int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; for (;;) &#123; .... if (result != 0) &#123; ..... return result; &#125; result = pollInner(timeoutMillis); &#125;&#125; 我们只看核心部分，这里主要是继续调用pollInner函数来进一步操作，如果pollInner返回不等于0，这个函数就可以返回了。 pollInner的定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687int Looper::pollInner(int timeoutMillis) &#123; ..... // Poll. int result = ALOOPER_POLL_WAKE; mResponses.clear(); mResponseIndex = 0; struct epoll_event eventItems[EPOLL_MAX_EVENTS]; int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); // Acquire lock. mLock.lock(); // Check for poll error. if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; ALOGW(\"Poll failed with an unexpected error, errno=%d\", errno); result = ALOOPER_POLL_ERROR; goto Done; &#125; // Check for poll timeout. if (eventCount == 0) &#123; ..... result = ALOOPER_POLL_TIMEOUT; goto Done; &#125; ..... for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeReadPipeFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents); &#125; &#125; else &#123; ..... &#125; &#125;Done: ; // Invoke pending message callbacks. mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) &#123; // Remove the envelope from the list. // We keep a strong reference to the handler until the call to handleMessage // finishes. Then we drop it so that the handler can be deleted *before* // we reacquire our lock. &#123; // obtain handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); .... handler-&gt;handleMessage(message); &#125; // release handler mLock.lock(); mSendingMessage = false; result = ALOOPER_POLL_CALLBACK; &#125; else &#123; // The last message left at the head of the queue determines the next wakeup time. mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; // Release lock. mLock.unlock(); // Invoke all response callbacks. ...... return result;&#125; 这个函数比较长并且其中用到了goto，我们仍然只关注核心代码，我们看到函数开头首先是调用epoll_wait函数来看看epoll专用文件描述符mEpollFd所监控的文件描述符是否有IO事件发生，它设置监控的超时时间为pollOnce函数传递过来的timeoutMillis： 1int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); 当mEpollFd所监控的文件描述符发生了要监控的IO事件后或者监控时间超时后，线程就从epoll_wait返回了，否则线程就会在epoll_wait函数中进入睡眠状态了。返回后如果eventCount等于0，就说明是超时了： 12345if (eventCount == 0) &#123; ...... result = ALOOPER_POLL_TIMEOUT; goto Done; &#125; 如果eventCount不等于0，就说明发生要监控的事件： 12345678910111213for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeReadPipeFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents); &#125; &#125; else &#123; ..... &#125; &#125; 这里我们只关注mWakeReadPipeFd文件描述符上的事件, 在Looper的构造函数中设置了要监控mWakeReadPipeFd文件描述符的EPOLLIN事件： 1234567891011121314151617181920212223242526272829303132Looper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123; int wakeFds[2]; int result = pipe(wakeFds); // 创建一个管道 LOG_ALWAYS_FATAL_IF(result != 0, \"Could not create wake pipe. errno=%d\", errno); mWakeReadPipeFd = wakeFds[0]; // 管道的“读取端” mWakeWritePipeFd = wakeFds[1]; // 管道的“写入端” result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK); LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake read pipe non-blocking. errno=%d\", errno); result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK); LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake write pipe non-blocking. errno=%d\", errno); // Allocate the epoll instance and register the wake pipe. // 创建一个epoll mEpollFd = epoll_create(EPOLL_SIZE_HINT); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, \"Could not create epoll instance. errno=%d\", errno); struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union eventItem.events = EPOLLIN; eventItem.data.fd = mWakeReadPipeFd; // 监听管道的read端 result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp; eventItem); LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake read pipe to epoll instance. errno=%d\",errno);&#125; 如果在mWakeReadPipeFd文件描述符上发生了EPOLLIN就说明应用程序中的消息队列里面有新的消息需要处理了，接下来它就会先调用awoken函数清空管道中的内容，以便下次再调用pollInner函数时，知道自从上次处理完消息队列中的消息后，有没有新的消息加进来。 awoken函数的实现很简单，它就是把管道中的内容都读取出来： 12345678void Looper::awoken() &#123; ..... char buffer[16]; ssize_t nRead; do &#123; nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer)); &#125; while ((nRead == -1 &amp;&amp; errno == EINTR) || nRead == sizeof(buffer));&#125; 因为当其它的线程向应用程序的消息队列加入新的消息时，会向这个管道写入新的内容来通知应用程序主线程有新的消息需要处理了，下面我们分析消息的发送的时候将会看到。 这样，消息的循环过程就分析完了，这部分逻辑还是比较复杂的，它利用Linux系统中的管道（pipe）进程间通信机制来实现消息的等待和处理，不过，了解了这部分内容之后，下面我们分析消息的发送和处理就简单多了。 3. 消息发送在线程(不管是UI线程还是子线程)中准备好消息队列并且进入消息循环后，其他地方就可以往这个消息队列中发送消息了。 在前面我们提到过Handler的构造方法，主要就是初始化类成员mLooper和mQueue。 123456789101112131415161718public class Handler &#123; ...... public Handler() &#123; ...... mLooper = Looper.myLooper(); ...... mQueue = mLooper.mQueue; ...... &#125; final MessageQueue mQueue; final Looper mLooper; ...... &#125; 有了Looper对象后，就可以通过mLooper.mQueue来访问消息队列了。发送消息的方法大家都不陌生，就是常用的sendMessage方法。在发送消息时，是可以指定消息的处理时间的，但是通过sendMessage函数发送的消息的处理时间默认就为当前时间，即表示要马上处理，因此，从sendMessage函数中调用sendMessageDelayed函数，传入的时间参数为0，表示这个消息不要延时处理，而在sendMessageDelayed函数中，则会先获得当前时间，然后加上消息要延时处理的时间，即得到这个处理这个消息的绝对时间，然后调用sendMessageAtTime函数来把消息加入到应用程序的消息队列中去。 在sendMessageAtTime函数，首先得到应用程序的消息队列mQueue，这是在Handler对象构造时初始化好的，前面已经分析过了，接着设置这个消息的目标对象target，即这个消息最终是由谁来处理的： 123456789101112131415161718 public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; 这里将它赋值为this，即表示这个消息最终由这个Handler对象来处理。 函数最后调用queue.enqueueMessage来把这个消息加入到消息队列中，具体实现在MessageQueue.java文件中： 12345678910111213141516171819202122232425262728293031323334353637383940414243final boolean enqueueMessage(Message msg, long when) &#123; ...... boolean needWake; synchronized (this) &#123; ....... msg.when = when; Message p = mMessages; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. // 此时，新消息会插入到链表的表头，这意味着队列需要调整唤醒时间啦。 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. // 此时，新消息会插入到链表的内部，一般情况下，这不需要调整唤醒时间。 // 但还必须考虑到当表头为“同步分隔栏”的情况 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; // 说明即便msg是异步的，也不是链表中第一个异步消息，所以没必要唤醒了 needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; &#125; if (needWake) &#123; nativeWake(mPtr); &#125; return true;&#125; 从这段代码来看MessageQueue说是一个消息队列，但它其实不是队列，而是一个链表。 把消息加入到消息队列时，分两种情况，一种当前消息队列为空时，这时候线程一般就是处于空闲等待状态了，这时候就要唤醒它，另一种情况是消息队列不为空，这时候就不需要唤醒线程了，因为这时候它一定是在忙着处于消息队列中的消息，因此不会处于空闲等待的状态。 第一种情况比较简单，只要把消息放在消息队列头就可以了： 123msg.next = p; mMessages = msg; needWake = mBlocked; 第二种情况相对就比较复杂一些了，前面我们说过，当往消息队列中发送消息时，是可以指定消息的处理时间的，而消息队列中的消息，就是按照这个时间从小到大来排序的，因此，当把新的消息加入到消息队列时，就要根据它的处理时间来找到合适的位置，然后再放进消息队列中去： 12345678910111213Message prev;for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125;&#125;msg.next = p; // invariant: p == prev.nextprev.next = msg; 把消息加入到消息队列去后，如果线程正处于空闲等待状态，就需要调用natvieWake函数来唤醒它了，这是一个JNI方法，定义在android_os_MessageQueue.cpp文件中： 1234static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); return nativeMessageQueue-&gt;wake();&#125; 这个JNI层的NativeMessageQueue对象我们在前面分析消息循环的时候创建好的，保存在Java层的MessageQueue对象的mPtr成员变量中，这里把它取回来之后，就调用它的wake函数来唤醒关联的线程，wake方法也在android_os_MessageQueue.cpp文件中： 123void NativeMessageQueue::wake() &#123; mLooper-&gt;wake();&#125; 这里它又通过成员变量mLooper的wake函数来执行操作，这里的mLooper成员变量是一个C++层实现的Looper对象，它定义在Looper.cpp文件中： 123456789void Looper::wake() &#123; ...... ssize_t nWrite; do &#123; nWrite = write(mWakeWritePipeFd, \"W\", 1); &#125; while (nWrite == -1 &amp;&amp; errno == EINTR); ......&#125; 这个wake函数很简单，只是通过打开文件描述符mWakeWritePipeFd往管道的写入一个”W”字符串。其实，往管道写入什么内容并不重要，往管道写入内容的目的是为了唤醒关联的线程。前面我们在分析应用程序的消息循环时说到，当消息队列中没有消息处理时，关联的线程就会进入空闲等待状态，而这个空闲等待状态就是通过调用这个Looper类的pollInner函数来进入的，具体就是在pollInner函数中调用epoll_wait函数来等待管道中有内容可读的。 这时候既然管道中有内容可读了，关联的线程就会从这里的Looper类的pollInner函数返回到JNI层的nativePollOnce函数，最后返回到Java层中的MessageQueue.next方法中去，这里它就会发现消息队列中有新的消息需要处理了，于就会处理这个消息。 4. 消息处理前面第一部分分析消息循环时，在Looper类的looper方法中进行消息循环的，这个方法中从消息队列中获取到消息对象msg后，就会调用它的target成员变量的dispatchMessage方法来处理这个消息。1234567891011121314151617 public static void loop() &#123; final Looper me = myLooper(); ...... final MessageQueue queue = me.mQueue;...... for (;;) &#123; Message msg = queue.next(); // might block ....... msg.target.dispatchMessage(msg); ...... msg.recycleUnchecked(); &#125; &#125; 在前面分析消息的发送时说过，这个消息对象msg的成员变量target是在发送消息的时候设置好的，通过哪个Handler来发送消息，就通过哪个Handler来处理消息。1234567891011121314public class Handler &#123; public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125;&#125; 这里的消息对象msg的callback成员变量和Handler类的mCallBack成员变量一般都为null，于是，就会调用Handler类的handleMessage方法来处理这个消息，这就到了我们平常使用Handler的时候重写的Handler的方法handlerMessage。 5. 总结 至此，我们就从消息循环、消息发送和消息处理三个部分分析完Android应用程序的消息处理机制了，为了更深理解，这里我们对其中的一些要点作一个总结： Android应用程序的消息处理机制由消息循环、消息发送和消息处理三个部分组成的。 Android应用程序的主线程在进入消息循环过程前，会在内部创建一个Linux管道（Pipe），这个管道的作用是使得Android应用程序主线程在消息队列为空时可以进入空闲等待状态，并且使得当应用程序的消息队列有消息需要处理时唤醒应用程序的主线程。 Android应用程序的主线程进入空闲等待状态的方式实际上就是在管道的读端等待管道中有新的内容可读，具体来说就是是通过Linux系统的Epoll机制中的epoll_wait函数进行的。 当往Android应用程序的消息队列中加入新的消息时，会同时往管道中的写端写入内容，通过这种方式就可以唤醒正在等待消息到来的应用程序主线程。 当应用程序主线程在进入空闲等待前，会认为当前线程处理空闲状态，于是就会调用那些已经注册了的IdleHandler接口，使得应用程序有机会在空闲的时候处理一些事情。 ​ 6. 问题最后，在前面的Looper部分相信很多人有个疑问 sThreadLocal在Looper类中是静态的，为什么线程A中已经调用了Looper.prepare给sThreadLocal设置了值，在线程B中直接调用Looper.myLooper从sThreadLocal中get值返回确是null？ 一个线程可以有几个Handler？ 一个线程可以有几个Looper？ 7. 补充内容7.1 ThreadLocal官方文档中对ThreadLocal的说明： 1234567891011/** * Implements a thread-local storage, that is, a variable for which each thread * has its own value. All threads share the same &#123;@code ThreadLocal&#125; object, * but each sees a different value when accessing it, and changes made by one * thread do not affect the other threads. The implementation supports * &#123;@code null&#125; values. * * @see java.lang.Thread */public class ThreadLocal&lt;T&gt; &#123;&#125; 这段话的意思是实现了一个线程相关的存储，即每个线程都有自己独立的变量。所有的线程都共享者这一个ThreadLocal对象，并且当一个线程的值发生改变之后，不会影响其他的线程的值。 ThreadLocal的类定义使用了泛型ThreadLocal&lt;T&gt;，其中T指代的是在线程中存取值的类型。（对应Android中使用的ThreadLocal, T则存放的类型为Looper） set方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Sets the value of this variable for the current thread. If set to * &#123;@code null&#125;, the value will be set to null and the underlying entry will * still be present. * * @param value the new value of the variable for the caller thread. */public void set(T value) &#123; Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values == null) &#123; values = initializeValues(currentThread); &#125; values.put(this, value);&#125;/** * Sets entry for given ThreadLocal to given value, creating an * entry if necessary. */void put(ThreadLocal&lt;?&gt; key, Object value) &#123; cleanUp(); // Keep track of first tombstone. That's where we want to go back // and add an entry if necessary. int firstTombstone = -1; for (int index = key.hash &amp; mask;; index = next(index)) &#123; Object k = table[index]; if (k == key.reference) &#123; // Replace existing entry. table[index + 1] = value; return; &#125; if (k == null) &#123; if (firstTombstone == -1) &#123; // Fill in null slot. table[index] = key.reference; table[index + 1] = value; size++; return; &#125; // Go back and replace first tombstone. table[firstTombstone] = key.reference; table[firstTombstone + 1] = value; tombstones--; size++; return; &#125; // Remember first tombstone. if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) &#123; firstTombstone = index; &#125; &#125;&#125; 简单地说，每个线程对象内部会记录一张逻辑上的key-value表，当我们在不同Thread里调用Looper.prepare()时，其实是向Thread对应的那张表里添加一个key-value项，其中的key部分，指向的是同一个对象，即Looper.sThreadLocal静态对象，而value部分，则彼此不同，我们可以画出如下示意图： ThreadLocal示意图 看到了吧，不同Thread会对应不同Object[]数组，该数组以每2个元素为一个key-value对。请注意不同Thread虽然使用同一个静态对象作为key值，最终却会对应不同的Looper对象。 7.2 同步分隔栏上面的代码中还有一个“同步分割栏”的概念需要提一下。所谓“同步分割栏”，可以被理解为一个特殊Message，它的target域为null。它不能通过sendMessageAtTime()等函数加入消息队列里，而只能通过调用Looper的postSyncBarrier()来加入消息队列。 “同步分割栏”是起什么作用的呢？它就像一个卡子，卡在消息链表中的某个位置，当消息循环不断从消息链表中摘取消息并进行处理时，一旦遇到这种“同步分割栏”，那么即使在分割栏之后还有若干已经到时的普通Message，也不会摘取这些消息了。请注意，此时只是不会摘取“普通Message”了，如果队列中还设置有“异步Message”，那么还是会摘取已到时的“异步Message”的。 在Android的消息机制里，“普通Message”和“异步Message”也就是这点儿区别啦，也就是说，如果消息列表中根本没有设置“同步分割栏”的话，那么“普通Message”和“异步Message”的处理就没什么大的不同了。 打入“同步分割栏”的postSyncBarrier()函数的代码如下：frameworks/base/core/java/android/os/Looper.java 123public int postSyncBarrier() &#123; return mQueue.enqueueSyncBarrier(SystemClock.uptimeMillis());&#125; frameworks/base/core/java/android/os/MessageQueue.java 1234567891011121314151617181920212223242526int enqueueSyncBarrier(long when) &#123; synchronized (this) &#123; final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125;&#125; 要得到“异步Message”，只需调用一下Message的setAsynchronous()即可：frameworks/base/core/java/android/os/Message.java 1234567public void setAsynchronous(boolean async) &#123; if (async) &#123; flags |= FLAG_ASYNCHRONOUS; &#125; else &#123; flags &amp;= ~FLAG_ASYNCHRONOUS; &#125;&#125; 一般，我们是通过“异步Handler”向消息队列打入“异步Message”的。异步Handler的mAsynchronous域为true，因此它在调用enqueueMessage()时，可以走入： 123if (mAsynchronous) &#123; msg.setAsynchronous(true);&#125; 现在我们画一张关于“同步分割栏”的示意图： img 图中的消息队列中有一个“同步分割栏”，因此它后面的“2”号Message即使到时了，也不会摘取下来。而“3”号Message因为是个异步Message，所以当它到时后，是可以进行处理的。 “同步分割栏”这种卡子会一直卡在消息队列中，除非我们调用removeSyncBarrier()删除这个卡子。frameworks/base/core/java/android/os/Looper.java 123public void removeSyncBarrier(int token) &#123; mQueue.removeSyncBarrier(token);&#125; frameworks/base/core/java/android/os/MessageQueue.java 12345678910111213141516171819202122232425262728293031void removeSyncBarrier(int token) &#123; // Remove a sync barrier token from the queue. // If the queue is no longer stalled by a barrier then wake it. synchronized (this) &#123; Message prev = null; Message p = mMessages; while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123; prev = p; p = p.next; &#125; if (p == null) &#123; throw new IllegalStateException(\"The specified message queue synchronization \" + \" barrier token has not been posted or has already been removed.\"); &#125; final boolean needWake; if (prev != null) &#123; prev.next = p.next; needWake = false; &#125; else &#123; mMessages = p.next; needWake = mMessages == null || mMessages.target != null; &#125; p.recycle(); // If the loop is quitting then it is already awake. // We can assume mPtr != 0 when mQuitting is false. if (needWake &amp;&amp; !mQuitting) &#123; nativeWake(mPtr); &#125; &#125;&#125; 和插入消息类似，如果删除动作改变了链表的头部，也意味着队列的最近唤醒时间应该被调整了，因此needWake会被设为true，以便代码下方可以走进nativeWake()。 参考文献Android应用程序消息处理机制（Looper、Handler）分析 聊一聊Android的消息机制 Android消息机制2-Handler(Native层) 相关源码Handler.java Looper.java MessageQueue.java Message.java Looper.cpp","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://jasonzhang1986.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jasonzhang1986.github.io/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-03-07T09:45:43.459Z","updated":"2017-03-07T09:45:43.466Z","comments":true,"path":"2017/03/07/hello-world/","link":"","permalink":"http://jasonzhang1986.github.io/2017/03/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]}]}