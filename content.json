{"meta":{"title":"JasonZhang's Blog","subtitle":null,"description":null,"author":"JasonZhang","url":"http://yoursite.com"},"pages":[{"title":"tags","date":"2017-03-10T10:18:27.000Z","updated":"2017-03-10T10:18:27.258Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"聊一聊Android的消息机制","slug":"消息机制","date":"2017-03-10T09:37:59.736Z","updated":"2017-03-10T10:21:41.129Z","comments":true,"path":"2017/03/10/消息机制/","link":"","permalink":"http://yoursite.com/2017/03/10/消息机制/","excerpt":"","text":"一、Android平台上，主要用到的通信机制有两种：Handler和Binder，前者用于进程内部的通信，后者主要用于跨进程通信。今天我们主要来聊一聊进程内部的消息机制Handler。 从技术实现来说消息机制并不复杂，不只是Android平台,各种平台的消息机制原理基本上都是比较相似的，其中用到的主要概念有： 消息发送者 消息队列 消息循环处理 简单示意图如下： 图中表达的意思是，消息发送者通过某种方式将消息发送到消息队列中，同时还有一个消息处理循环，不断从消息队列里取消息，并进行处理。 Android的消息机制主要是指Handler的运行机制，Hander的运行需要相关的MessageQueue和Looper的支撑。图中右侧的部分可以理解为Android中的Looper类，这个类的内部有对应的消息队列(MessageQueue mQueue)和loop方法(取消息的循环) 从我们开发者的角度来说，Handler是Android消息机制的最上层接口，这使得我们在开发过程中绝大多数情况下只需要和Handler打交道就可以，Handler的使用方法也很简单，我们常常在子线程中需要更新UI时使用，常见代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case xxx: ... updateUI(); break; &#125; &#125; &#125;; .... private void threadMethod() &#123; new Thread()&#123; @Override public void run() &#123; super.run(); ... handler.sendMessage(msg); ... &#125; &#125;.start(); &#125; //在子线程中使用Handler class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125; &#125; 从实例代码中我们看到消息机制三步中消息发送(sendMessage)，那另外两步(消息循环和消息处理)在哪里呢？我们跟踪进入Handler的源码中看一看123456789101112131415161718192021222324252627public Handler() &#123; this(null, false);&#125;public Handler(Looper looper) &#123; this(looper, null, false);&#125;public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 从Handler的构造方法中看，我们使用默认的构造方法使用的Looper是通过Looper.myLooper()获取到的，紧接着一行有判断mLooper==null时抛出一个RuntimeException，意思是在没有调用Looper.prepare()方法时是不能在Thread中创建Handler对象的，这里有个问题，我们在Activity(UI线程)中new Handler的时候也没有看到调用Looper.prepare()方法，为什么没有抛出这个RuntimeException呢？ 你是不是觉得系统在Looper.myLooper()中做了什么操作？那我们来继续跟进去看看Looper.myLooper()都做了什么。1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static Looper myLooper() &#123; return sThreadLocal.get();&#125; 奇怪，这里只是调用了sThreadLocal的get方法获取了Looper对象并返回，并没有调用Looper.prepare(),那为什么不会抛异常呢？是因为UI线程特殊吗？？ 答案显然不是，了解应用启动流程的应该知道，应用的main方法在ActivityThread中，在main方法中完成了一些初始化工作，我们来看main方法中做了什么12345678910111213141516public static void main(String[] args) &#123; ... Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if(sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ... Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 我们看到在main中有调用Looper.prepareMainLooper(),跟进去看1234567891011121314151617181920212223public static void prepareMainLooper() &#123; prepare(false); Class var0 = Looper.class; synchronized(Looper.class) &#123; if(sMainLooper != null) &#123; throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); &#125; else &#123; sMainLooper = myLooper(); &#125; &#125;&#125;public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if(sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; else &#123; sThreadLocal.set(new Looper(quitAllowed)); &#125;&#125; 可以看到prepareMainLooper()和prepare()调用的是Looper的同一个方法prepard(boolean quitAllowed)，UI线程的Looper是不允许退出的(如果允许退出，调用了quit岂不UI就无法刷新啦)，其他线程的Looper是允许退出的。 prepare方法调用后，创建Handler,这里是new ActivityThread对象，ActivityThread有实例变量mH就是Handler的对象12345678910111213141516171819202122main() &#123; ... ActivityThread thread = new ActivityThread(); if(sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; ...&#125; final ActivityThread.H mH = new ActivityThread.H(null);final Handler getHandler() &#123; return this.mH;&#125;...private class H extends Handler &#123; ...&#125; 到这里Looper和Handler都准备好，开始消息循环Looper.loop()。aaaa","raw":null,"content":null,"categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-03-07T09:45:43.459Z","updated":"2017-03-07T09:45:43.466Z","comments":true,"path":"2017/03/07/hello-world/","link":"","permalink":"http://yoursite.com/2017/03/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":[],"tags":[]}]}